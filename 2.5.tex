%!TEX root = main.tex
Al igual que en la sección anterior las soluciones de este capitulo no son únicas y puede que algunas sean redundantes, además otra aclaración de vital importancia es que todos los autómatas presentados no se muestran sus estados limbo, es decir presentaremos AFD simplificados.\\

\textbf{Punto 1:}
\begin{itemize}[label={✎}]
    \item Como la cadena mínima es $\lambda$ entonces el estado inicial tiene que ser de aceptación, luego como también se aceptan $aes$ arbitrarias estas pueden ser aceptadas por medio de un bucle. Apenas aparezca una $b$ el autómata cambiara de estado pero ese seria también de aceptación, incluyendo un bucle para las $bes$ arbitrarias:\\
    \begin{center}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0, accepting] {$q_1$};
            \path [thick]
            (q0) edge [loop above] node {$a$} ()
            (q0) edge node [above] {$b$} (q1)
            (q1) edge [loop above] node {$b$} ();
        \end{tikzpicture}
    \end{center}

    \item Nuevamente el estado inicial es de aceptación ya que $\lambda$ pertenece a el lenguaje, luego basta con tomar dos caminos para el caso donde sean cadenas de $aes$ y el de cadenas de $bes$:
    \begin{center}
        \begin{tikzpicture}[node distance = 2cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q1) [state, above right of=q0, accepting] {$q_1$};
            \node (q2) [state, below right of=q0, accepting] {$q_2$};
            \path[thick]
            (q0) edge [bend left] node [above left] {$a$} (q1)
            (q0) edge [bend right] node [below left] {$b$} (q2)
            (q1) edge [loop above] node {$a$} ()
            (q2) edge [loop below] node {$b$} ();
        \end{tikzpicture}    
    \end{center}

    \item Note que todas las cadenas de este lenguaje son de la forma $ab\dots ab$, es decir siempre son bloques $ab$ y todas las cadenas empiezan en $a$ y terminan en $b$:
    \begin{center}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$b$} (q0);
        \end{tikzpicture}
    \end{center}

    \item Bastante similar a la anterior excepto que la cadena mínima aceptada es $ab$ debido al $+$, así que forzamos esa cadena:
    \begin{center}
        \begin{tikzpicture} [node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, accepting, right of=q1] {$q_2$};
            \path[thick]
            (q0) edge node [above] {$a$} (q1)
            (q1) edge [bend left] node [above] {$b$} (q2)
            (q2) edge [bend left] node [below] {$a$} (q1);
        \end{tikzpicture}     
    \end{center}

    \item Note que debido a la expresión se forman dos caminos, uno son las cadenas que empiezan por $a$ y luego tienen una cantidad de $bes$ arbitrarias. El otro son aquellas que comienzan por un numero de $bes$ arbitrarias pero están forzadas a terminar en $a$ para ser aceptadas:
    \begin{center}
        \begin{tikzpicture} [node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, below right of=q0, accepting] {$q_1$};
            \node (q2) [state, above right of=q0] {$q_2$};
            \node (q3) [state,  below right of=q2, accepting] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above left] {$b$} (q2)
            (q0) edge [bend right] node [below left] {$a$} (q1)
            (q1) edge [loop below] node [below] {$b$} ()
            (q2) edge [loop above] node [above] {$b$} ()
            (q2) edge [bend left] node [above right] {$a$} (q3);
        \end{tikzpicture}
    \end{center}

    \item Observe que las cadena minima de este lenguaje tiene una sola $a$ asi que el estado inicial no es de acpetación, luego note que en ambos casos de la $*$ el elemento es una $a$, por lo que forzamos dos $aes$ y posteriormente realizamos respectivamente el bucle de $aes$ y de $abes$: 
    \begin{center}
        \begin{tikzpicture} [node distance = 2.5cm, on grid, auto]
                \node (q0) [state, initial] {$q_0$};
                \node (q1) [state, right of=q0, accepting] {$q_1$};
                \node (q2) [state, right of=q1, accepting] {$q_2$};
                \path[thick]
                (q0) edge node [above] {$a$} (q1)
                (q1) edge [bend left] node [above] {$a$} (q2)
                (q2) edge [loop above] node [above] {$a$} ()
                (q2) edge [bend left] node [below] {$b$} (q1);
        \end{tikzpicture}
    \end{center}
    
    \item Observe que la cadena minima es $aa$ entonces debemos forzar ese camino. Ahora note que en ese camino podemos generar el bucle para $a^+$. Note que hay dos posibilidades para las $bes$, o inicia la cadena con solo una $a$ y luego tiene una cantidad arbitraria de $bes$ o empieza con $aes$ arbitrarias y luego tiene $bes$ arbitrarias, pero note que siempre que aparece al menos una $b$ la cadena siempre acaba en $a$:

    \begin{center}
        \begin{tikzpicture} [node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, accepting, below right of=q1] {$q_2$};
            \node (q3) [state, above right of=q1] {$q_3$};
            \node (q4) [state, accepting, below right of=q3] {$q_4$};
            \path[thick]
            (q0) edge node [above] {$a$} (q1)
            (q1) edge [bend left] node [above] {$b$} (q3)
            (q1) edge [bend right] node [below] {$a$} (q2)
            (q2) edge [loop below] node [below] {$a$} ()
            (q2) edge node [right] {$b$} (q3)
            (q3) edge [loop above] node [above] {$b$} ()
            (q3) edge [bend left] node [above] {$a$} (q4);
        \end{tikzpicture}
    \end{center}

    \item Primero notemos que las cadenas minimas son $a$ y $b$, asi que debemos forzar dos caminos que las acepten. Ahora observe que si sale una $a$ existen dos posibilidades, es seguida inmediatamente de una $b$ o salen $aes$ arbitrarias y luego si una $b$. Note que este analisis tambien es valido respectivamente con $b$:

        \begin{center}
            \begin{tikzpicture} [node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, above right of=q0, accepting] {$q_1$};
            \node (q5) [state, below right of=q1, accepting] {$q_5$};
            \node (q2) [state, above right of=q5] {$q_2$};
            \node (q3) [state, below right of=q0, accepting] {$q_3$};
            \node (q4) [state, below right of=q5] {$q_4$};
            
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q0) edge [bend right] node [below] {$b$} (q3)
            (q1) edge node [above] {$a$} (q2)
            (q3) edge node [below] {$b$} (q4)
            (q2) edge [loop above] node [above] {$a$} ()
            (q4) edge [loop below] node [below] {$b$} ()
            (q2) edge node [below] {$b$} (q5)
            (q4) edge node [above] {$a$} (q5)
            (q1) edge node [below] {$b$} (q5)
            (q3) edge node [above] {$a$} (q5);     
            \end{tikzpicture}
        \end{center}

        \item Observe que nuestras dos cadenas minimas de aceptacion son $ab$ y $ba$ asi que forzamos esos dos caminos. Posterirmente para hacer que aparezcan las $bes$ arbitrarias podemos agregar un bucle en el camino donde generamos $ba$. Si lo dejaramos hasta ahi nos faltarian las cadenas de la forma $b^*ab$ pero esto se arregla facilmente conectando el camino de $ba$ al de $ab$ colocando una $b$ entre estados de aceptacion:
        \begin{center}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
                \node (q0) [state, initial] {$q_0$};
                \node (q1) [state, above right of=q0] {$q_1$};
                \node (q2) [state, right of=q1, accepting] {$q_2$};
                \node (q3) [state, below right of=q0] {$q_3$};
                \node (q4) [state, right of=q3, accepting] {$q_4$};
                \path[thick]
                (q0) edge [bend left] node [above] {$a$} (q1)
                (q1) edge node [above] {$b$} (q2)
                (q0) edge [bend right] node [below] {$b$} (q3)
                (q3) edge [loop below] node [below] {$b$} ()
                (q3) edge node [below] {$a$} (q4)
                (q4) edge node [right] {$b$} (q2);
            \end{tikzpicture}
        \end{center}

        \item Note que el lenguaje es muy parecido a excepcion de que las cadenas forzosamente acaban en por lo menos una $a$, pero lo que podemos hacer es usar el automata construido previamente y aquellos estados de aceptacion forzamos que salga una $a$ hacia un nuevo estado de aceptacion que generara la concatenacion de $a^+$:

        \begin{center}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
                \node (q0) [state, initial] {$q_0$};
                \node (q1) [state, above right of=q0] {$q_1$};
                \node (q2) [state, right of=q1] {$q_2$};
                \node (q3) [state, below right of=q0] {$q_3$};
                \node (q4) [state, right of=q3] {$q_4$};
                \node (q5) [state, above right of=q4, accepting] {$q_5$};
                \path[thick]
                (q0) edge [bend left] node [above] {$a$} (q1)
                (q1) edge node [above] {$b$} (q2)
                (q0) edge [bend right] node [below] {$b$} (q3)
                (q3) edge [loop below] node [below] {$b$} ()
                (q3) edge node [below] {$a$} (q4)
                (q4) edge node [right] {$b$} (q2)
                (q2) edge [bend left] node [above] {$a$} (q5)
                (q4) edge [bend right] node [below] {$a$} (q5)
                (q5) edge [loop right] node [right] {$a$} ();
            \end{tikzpicture}
        \end{center} 


\textbf{Punto 2:}
    
\end{itemize}