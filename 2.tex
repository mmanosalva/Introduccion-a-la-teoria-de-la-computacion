%!TEX root = main.tex
En este capítulo comenzamos la segunda parte de las notas de clase, en estas secciones resaltamos que no hay una única solución a los ejercicios y que algunas de las soluciones pueden llegar a ser redundantes, sin embargo son funcionales y esto es lo que más nos interesa.

\section{Expresiones regulares}

\textbf{Punto 1:} \begin{itemize}
    \item [✎] La solución más evidente es la siguiente: $b(a\cup b)^*a$, con $(a\cup b)^*$ consideramos todas las cadenas y lo que hacemos es forzar que las cadenas comiencen con $b$ y terminen en $a$ concatenando.

    \item[✎] Sabemos que para generar todas las cadenas de longitud par usamos $(aa\cup bb\cup ab\cup ba)^*=((a\cup b)(a\cup b))^*$, luego para generar las impares debemos considerar 4 casos y unirlos:

    $$a((a\cup b)(a\cup b))^*\cup b((a\cup b)(a\cup b))^* \cup ((a\cup b)(a\cup b))^*a \cup ((a\cup b)(a\cup b))^*b$$

    Esto convierte las cadenas pares en impares siempre y considera los casos en que comience por $a$ o por $b$ o termine por $a$ o $b$ (se puede llegar a una solución mejor quizá).

    \item[✎] Sabemos que $(b^*ab^*ab^*)^*$ genera todas las cadenas con un número par (mayor que 0) de $aes$, luego usando este hecho construimos:

    $$a(b^*ab^*ab^*)^*\cup (b^*ab^*ab^*)^*a$$

    y acabamos.

    \item[✎] Sabemos generar las cadenas de $a$ y $b$ que contienen un número par de $a$ o $b$, la solución está propuesta en las notas de clase, luego cambiamos un poco la expresión de esta forma:

    $$a^*(a^*ba^*ba^*ba^*)^*$$

    La expresión $a^*(ba^*ba^*b)^*a^*$ también es una solución.

    \item[✎] Para este caso las cadenas pueden comenzar por $a$, $ab$, $b^2$, $a^2$, luego obtenemos la expresión:

    $$(a\cup ab \cup b^2 \cup a^2)(a \cup b)^*a $$

    Ya que tampoco pueden acabar en $b$, ahora no falta notas que por agregar esta $a$ al final y la expresión $(a\cup ab \cup b^2 \cup a^2)$ es imposible obtener la cadena vacía y la cadena $a$, pues las añadimos y nos queda finalmente:

     $$(a\cup ab \cup b^2 \cup a^2)(a \cup b)^*a \cup a \cup \lambda$$

     \item[✎] Para la expresión regular en este caso notemos que toda cadena tiene bloques de la forma $ba$ donde estos van intercalados con un numero de $a$ arbitrarias así obtenemos la expresión:

     $$(a\cup ba)^*$$

     Observe que las $b$ están restringidas ya que para $b\geq 2$ las cadenas de este estilo no pueden tener una $a$ luego de la cantidad arbitraria de $bes$, pero esta expresión no contempla las cadenas del estilo $bb\dots b$, para esto basta concatenar estas cadenas al final, obteniendo finalmente la expresión:

     $$(a\cup ba)^*b^*$$

\end{itemize}

\textbf{Punto 2:} \begin{itemize}
    \item[✎] Al igual que en el primer ítem del punto anterior, lo mas natural es forzar que la cadena empiece en con $2$ y termine en $1$, concatenando respectivamente obtenemos la expresión $2(0\cup1\cup2)^*1$.

    \item[✎] Similar a la construcción anterior podemos forzar a que las cadenas no empiecen con $2$ ni terminen con $1$ concatenando $(0\cup1)$ y $(0\cup2)$ respectivamente. De esta forma obtenemos la expresión:
    
    $$(0\cup1)(0\cup1\cup2)^*(0\cup2)$$

    Note que en el lenguaje propuesto las cadenas $\lambda$ y $0$ también cumplen la condición, pero es imposible generarlas por medio de la expresión dada. Afortunadamente arreglar esto es sencillo ya que podemos agregarlas por medio de uniones, obteniendo así:

    $$(0\cup1)(0\cup1\cup2)^*(0\cup2)\cup\lambda\cup0$$

    \item[✎] Nuevamente la forma mas natural de construir la expresión que represente al lenguaje es forzando que aparezcan solo $2$ ceros, tenga en cuenta que los ceros pueden estar en cualquier posición y por tanto la expresión es la siguiente $(1\cup2)^*0(1\cup2)^*0(1\cup2)^*$.

    \item[✎] Ya sabemos como generar los bloques de dos elementos de un lenguaje, para este caso $(0\cup1\cup2)(0\cup1\cup2)=(0\cup1\cup2)^2$, luego de esto basta concatenar estos bloques de todas la formas posibles, obteniendo así la expresión:

    $$\left((0\cup1\cup2)^2\right)^*$$

    \item[✎] Usando la expresión del ítem anterior, si concatenamos al final $0$,$1$ o $2$ obtenemos las cadenas de longitud impar, es decir:
    
    $$\left((0\cup1\cup2)^2\right)^*(0\cup1\cup2)$$

    \item[✎] Como no pueden aparecer dos unos consecutivos, las cadenas contienen bloques de la forma $(0\cup2)1(0\cup2)$, y junto a ellas cantidades arbitrarias de ceros y dos alternados:

    $$(0\cup2\cup(0\cup2)1(0\cup2))^*$$

    Observe que si bien esta expresión nos da múltiples cadenas aun hay varias que no genera. Por ejemplo no genera cadenas que empiecen o terminen en $1$. Esto podemos agregarlo concatenado $1\cup\lambda$ al inicio y final de la expresión:

    $$(1\cup\lambda)(0\cup2\cup(0\cup2)1(0\cup2))^+(1\cup\lambda)$$

    La cadena $\lambda$ es de vital importancia en la expresión ya que esta nos permite concatenar sin perder las cadenas que ya teníamos previamente. Además note que en la expresión cambiamos la $*$ por un $+$, esto se debe a que si no realizamos este cambio generaríamos la cadena $11$ y esta no cumple los criterios del lenguaje, por ultimo las cadenas $\lambda$ y $1$ cumplen las condiciones, mas no pueden ser generadas por lo que solo queda agregarlas y así obtener la expresión final:

    $$(1\cup\lambda)(0\cup2\cup(0\cup2)1(0\cup2))^+(1\cup\lambda)\cup\lambda\cup1$$
\end{itemize}

\textbf{Punto 3:} \begin{itemize}
    \item[✎] Para que una cadena tenga al menos un $0$ y un $1$ debe ser mínimo un bloque $01$ o un bloque $10$, luego simplemente fijamos esas dos posibilidades para que la solución sea  $(0\cup1)^*(01\cup10)(0\cup1)^*$.

    \item[✎]La condición nos indica que en las cadenas solo pueden haber uno o dos ceros consecutivos, es decir las forman bloque de la forma $01$ o $001$, luego podemos generar la expresión:

    $$(1\cup01\cup001)^*$$

    Note que esta  no contempla cadenas que terminen en uno o dos ceros, pero esto lo podemos arreglar fácilmente concatenando lo necesario:

    $$(1\cup01\cup001)^*(\lambda\cup0\cup00)$$

    \item[✎]Para esta solución simplemente consideremos las cadenas de longitud $4$ es decir las que son generadas por $(0\cup1)^4$, luego como estas son las mínimas cadenas que acepta el lenguaje solo queda hacer que aparezcan las demás posibilidades así $(0\cup1)^4(0\cup1)^*$.

    \item[✎]Note que al forzar que el quinto símbolo de izquierda a derecha sea un $1$ en todas las cadenas básicamente podemos rehusar la solución anterior forzando la condición de esta forma $(0\cup1)^41(0\cup1)^*$.

    \item[✎]Si la cadena no puede terminar en $01$ forzosamente tiene que terminar en $00,10$ o $11$, forzando estas obtenemos:

    $$(0\cup1)^*(00\cup10\cup11)$$

    Observe que esta expresión solo genera cadenas de longitud $\geq2$ pero las cadenas $\lambda,0$ y $1$ cumplen la condición, entonces:

    $$(0\cup1)^*(00\cup10\cup11)\cup\lambda\cup0\cup1$$

    De esta forma terminamos.

    \item[✎]Como son cadenas de longitud par, pueden ser formadas por bloques de la forma $01$ o de la forma $10$ luego la solución luce de esta forma $(01)^+\cup(10)^+$. Note que usamos $+$ ya que la cadena $\lambda$ no es aceptada en este lenguaje.

    \item[✎]Como en el ejercicio anterior ya construimos las cadenas pares, solo nos queda construir todas las impares. Esto lo logramos por medio de concatenar un elemento mas a las expresiones que ya tenemos. La solución luce de la siguiente forma:

    $$(1\cup\lambda)(01)^+\cup(0\cup\lambda)(10)^+$$

    \item[✎]Note que si no pueden haber dos ceros seguidos ni dos unos seguidos, los ceros y los unos deben de ir alternados forzosamente, es decir que la solución es la misma que la del ejercicio previo, exceptuando un detalle:

     $$(1\cup\lambda)(01)^*\cup(0\cup\lambda)(10)^*$$

     Observe que cambiamos el $+$ por una $*$, esto se debe a que las cadenas $\lambda,0$ y $1$ si son validas en este lenguaje.

     \item[✎]Para generar cadenas cuya longitud es un múltiplo de 3, necesitamos todos los bloques de longitud $3$ y posteriormente los concatenamos de todas las formas posibles, es decir tenemos la expresión $\left((0\cup1)^3\right)^*$. Recuerde que $0$ es múltiplo de $3$ por eso usamos el $*$ para asegurar la cadena $\lambda$.

      \item[✎]Esta expresión sigue un análisis muy similar al de las cadenas donde no podían haber tres ceros consecutivos, de esta forma solo falta agregar los bloques $0001$ y $000$ respectivamente a la expresión que habíamos obtenido:

      $$(1\cup01\cup001\cup0001)^*(\lambda\cup0\cup00\cup000)$$

      \item[✎]Observe que la cadena tiene que empezar por $1$ o $01$ y de forma similar tiene que acabar en $0$ o en $01$. Forzando estos símbolos obtenemos:

      $$(1\cup01)(0\cup1)^*(0\cup01)$$

      Ahora como usualmente ha ocurrido a lo largo de esta sección, al forzar cadenas en la expresión, no generamos cadenas que si son aceptadas dentro del lenguaje, pero basta con simplemente agregarlas:

      $$(1\cup01)(0\cup1)^*(0\cup01)\cup\lambda\cup0\cup1\cup01$$

      \item[✎]Para que no contengan la subcadena $101$ note que se debe forzar que en todas las expresiones aparezcan al menos dos ceros entre dos unos, las cadenas de este estilo se consiguen por medio de la expresión:

      $$(1\cup00^+)^*$$

      Uno podría verse tentado en pensar que esta es la solución, pero observe que esta expresión no contempla cadenas que empiecen por $01$ y que son totalmente validas, además tampoco contempla cadenas que terminen en un solo cero:

      $$(01\cup\lambda)(1\cup00^+)^*(0\cup\lambda)$$

      Luego de este arreglo si podemos asegurar que están todas las cadenas.
  
\end{itemize}

\hfill $\blacklozenge$

\section{Diseño de autómatas}


Al igual que en la sección anterior las soluciones de este capitulo no son únicas y puede que algunas sean redundantes, además otra aclaración de vital importancia es que todos los autómatas presentados no muestran sus estados limbo, es decir presentaremos AFD simplificados.\\

\textbf{Punto 1:}
\begin{itemize}[label={✎}]
    \item Como la cadena mínima es $\lambda$ entonces el estado inicial tiene que ser de aceptación, luego como también se aceptan $aes$ arbitrarias estas pueden ser aceptadas por medio de un bucle. Apenas aparezca una $b$ el autómata cambiara de estado pero ese seria también de aceptación, incluyendo un bucle para las $bes$ arbitrarias:\\
    \begin{basedtikz}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0, accepting] {$q_1$};
            \path [thick]
            (q0) edge [loop above] node {$a$} ()
            (q0) edge node [above] {$b$} (q1)
            (q1) edge [loop above] node {$b$} ();
        \end{tikzpicture}
    \end{basedtikz}

    \item Nuevamente el estado inicial es de aceptación ya que $\lambda$ pertenece a el lenguaje, luego basta con tomar dos caminos para el caso donde sean cadenas de $aes$ y el de cadenas de $bes$:
    \begin{basedtikz}
        \begin{tikzpicture}[node distance = 2cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q1) [state, above right of=q0, accepting] {$q_1$};
            \node (q2) [state, below right of=q0, accepting] {$q_2$};
            \path[thick]
            (q0) edge [bend left] node [above left] {$a$} (q1)
            (q0) edge [bend right] node [below left] {$b$} (q2)
            (q1) edge [loop above] node {$a$} ()
            (q2) edge [loop below] node {$b$} ();
        \end{tikzpicture}    
    \end{basedtikz}

    \item Note que todas las cadenas de este lenguaje son de la forma $ab\dots ab$, es decir siempre son bloques $ab$ y todas las cadenas empiezan en $a$ y terminan en $b$:
    \begin{basedtikz}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$b$} (q0);
        \end{tikzpicture}
    \end{basedtikz}

    \item Bastante similar a la anterior excepto que la cadena mínima aceptada es $ab$ debido al $+$, así que forzamos esa cadena:
    \begin{basedtikz}
        \begin{tikzpicture} [node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, accepting, right of=q1] {$q_2$};
            \path[thick]
            (q0) edge node [above] {$a$} (q1)
            (q1) edge [bend left] node [above] {$b$} (q2)
            (q2) edge [bend left] node [below] {$a$} (q1);
        \end{tikzpicture}     
    \end{basedtikz}

    \item Note que debido a la expresión se forman dos caminos, uno son las cadenas que empiezan por $a$ y luego tienen una cantidad de $bes$ arbitrarias. El otro son aquellas que comienzan por un numero de $bes$ arbitrarias pero están forzadas a terminar en $a$ para ser aceptadas:
    \pagebreak
    \begin{basedtikz}
        \begin{tikzpicture} [node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, below right of=q0, accepting] {$q_1$};
            \node (q2) [state, above right of=q0] {$q_2$};
            \node (q3) [state,  below right of=q2, accepting] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above left] {$b$} (q2)
            (q0) edge [bend right] node [below left] {$a$} (q1)
            (q1) edge [loop below] node [below] {$b$} ()
            (q2) edge [loop above] node [above] {$b$} ()
            (q2) edge [bend left] node [above right] {$a$} (q3);
        \end{tikzpicture}
    \end{basedtikz}

    \item Observe que las cadena mínima de este lenguaje tiene una sola $a$ así que el estado inicial no es de aceptación, luego note que en ambos casos de la $*$ el elemento es una $a$, por lo que forzamos dos $aes$ y posteriormente realizamos respectivamente el bucle de $aes$ y de $abes$:

    \begin{basedtikz}
        \begin{tikzpicture} [node distance = 2.5cm, on grid, auto]
                \node (q0) [state, initial] {$q_0$};
                \node (q1) [state, right of=q0, accepting] {$q_1$};
                \node (q2) [state, right of=q1, accepting] {$q_2$};
                \path[thick]
                (q0) edge node [above] {$a$} (q1)
                (q1) edge [bend left] node [above] {$a$} (q2)
                (q2) edge [loop above] node [above] {$a$} ()
                (q2) edge [bend left] node [below] {$b$} (q1);
        \end{tikzpicture}
    \end{basedtikz}
     
    \item Observe que la cadena mínima es $aa$ entonces debemos forzar ese camino. Ahora note que en ese camino podemos generar el bucle para $a^+$. Note que hay dos posibilidades para las $bes$, o inicia la cadena con solo una $a$ y luego tiene una cantidad arbitraria de $bes$ o empieza con $aes$ arbitrarias y luego tiene $bes$ arbitrarias, pero note que siempre que aparece al menos una $b$ la cadena siempre acaba en $a$:
    \pagebreak
    \begin{basedtikz}
        \begin{tikzpicture} [node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, accepting, below right of=q1] {$q_2$};
            \node (q3) [state, above right of=q1] {$q_3$};
            \node (q4) [state, accepting, below right of=q3] {$q_4$};
            \path[thick]
            (q0) edge node [above] {$a$} (q1)
            (q1) edge [bend left] node [above] {$b$} (q3)
            (q1) edge [bend right] node [below] {$a$} (q2)
            (q2) edge [loop below] node [below] {$a$} ()
            (q2) edge node [right] {$b$} (q3)
            (q3) edge [loop above] node [above] {$b$} ()
            (q3) edge [bend left] node [above] {$a$} (q4);
        \end{tikzpicture}
    \end{basedtikz}

    \item Primero notemos que las cadenas mínimas son $a$ y $b$, así que debemos forzar dos caminos que las acepten. Ahora observe que si sale una $a$ existen dos posibilidades, es seguida inmediatamente de una $b$ o salen $aes$ arbitrarias y luego si una $b$. Note que este análisis también es valido respectivamente con $b$:

        \begin{basedtikz}
            \begin{tikzpicture} [node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, above right of=q0, accepting] {$q_1$};
            \node (q5) [state, below right of=q1, accepting] {$q_5$};
            \node (q2) [state, above right of=q5] {$q_2$};
            \node (q3) [state, below right of=q0, accepting] {$q_3$};
            \node (q4) [state, below right of=q5] {$q_4$};
            
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q0) edge [bend right] node [below] {$b$} (q3)
            (q1) edge node [above] {$a$} (q2)
            (q3) edge node [below] {$b$} (q4)
            (q2) edge [loop above] node [above] {$a$} ()
            (q4) edge [loop below] node [below] {$b$} ()
            (q2) edge node [below] {$b$} (q5)
            (q4) edge node [above] {$a$} (q5)
            (q1) edge node [below] {$b$} (q5)
            (q3) edge node [above] {$a$} (q5);     
            \end{tikzpicture}
        \end{basedtikz}

        \item Observe que nuestras dos cadenas mínimas de aceptación son $ab$ y $ba$ así que forzamos esos dos caminos. Posteriormente para hacer que aparezcan las $bes$ arbitrarias podemos agregar un bucle en el camino donde generamos $ba$. Si lo dejáramos hasta ahí nos faltarían las cadenas de la forma $b^*ab$ pero esto se arregla fácilmente conectando el camino de $ba$ al de $ab$ colocando una $b$ entre estados de aceptación:
        \pagebreak
        \begin{basedtikz}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
                \node (q0) [state, initial] {$q_0$};
                \node (q1) [state, above right of=q0] {$q_1$};
                \node (q2) [state, right of=q1, accepting] {$q_2$};
                \node (q3) [state, below right of=q0] {$q_3$};
                \node (q4) [state, right of=q3, accepting] {$q_4$};
                \path[thick]
                (q0) edge [bend left] node [above] {$a$} (q1)
                (q1) edge node [above] {$b$} (q2)
                (q0) edge [bend right] node [below] {$b$} (q3)
                (q3) edge [loop below] node [below] {$b$} ()
                (q3) edge node [below] {$a$} (q4)
                (q4) edge node [right] {$b$} (q2);
            \end{tikzpicture}
        \end{basedtikz}

        \item Note que el lenguaje es muy parecido a excepción de que las cadenas forzosamente acaban en por lo menos una $a$, pero lo que podemos hacer es usar el autómata construido previamente y aquellos estados de aceptación forzamos que salga una $a$ hacia un nuevo estado de aceptación que generara la concatenación de $a^+$:

        \begin{basedtikz}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
                \node (q0) [state, initial] {$q_0$};
                \node (q1) [state, above right of=q0] {$q_1$};
                \node (q2) [state, right of=q1] {$q_2$};
                \node (q3) [state, below right of=q0] {$q_3$};
                \node (q4) [state, right of=q3] {$q_4$};
                \node (q5) [state, above right of=q4, accepting] {$q_5$};
                \path[thick]
                (q0) edge [bend left] node [above] {$a$} (q1)
                (q1) edge node [above] {$b$} (q2)
                (q0) edge [bend right] node [below] {$b$} (q3)
                (q3) edge [loop below] node [below] {$b$} ()
                (q3) edge node [below] {$a$} (q4)
                (q4) edge node [right] {$b$} (q2)
                (q2) edge [bend left] node [above] {$a$} (q5)
                (q4) edge [bend right] node [below] {$a$} (q5)
                (q5) edge [loop right] node [right] {$a$} ();
            \end{tikzpicture}
        \end{basedtikz} 
    \end{itemize}
\textbf{Punto 2:}
\begin{itemize}[label={✎}]
    \item Recordemos que si por ejemplo queremos construir un autómata que acepte el lenguaje de las cadenas que tienen una cantidad par de $aes$ hacemos la siguiente construcción:
    \begin{basedtikz}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0);
        \end{tikzpicture}
    \end{basedtikz}
Note como la construcción para cantidad par de $bes$ es la misma entonces basta simplemente con agregar un camino para estas en el autómata ya diseñado hacia un nuevo estado:
\begin{basedtikz}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, below of=q0] {$q_2$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge [bend left] node [right] {$b$} (q2)
            (q2) edge [bend left] node [left] {$b$} (q0);
        \end{tikzpicture}
    \end{basedtikz}

Observe que este autómata no acepta por ejemplo las cadenas $abab$ o $abba$. Aquí entra en juego la recomendación de usar 4 estados para la construcción y de esta forma podremos crear estos caminos para aceptar aquellas cadenas que antes no y que si son generadas por el lenguaje:

\begin{basedtikz}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, below of=q0] {$q_2$};
            \node (q3) [state, below of=q1] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge [bend left] node [right] {$b$} (q2)
            (q2) edge [bend left] node [left] {$b$} (q0)
            (q2) edge [bend left] node [above] {$a$} (q3)
            (q3) edge [bend left] node [below] {$a$} (q2)
            (q1) edge [bend left] node [right] {$b$} (q3)
            (q3) edge [bend left] node [left] {$b$} (q1);
        \end{tikzpicture}
    \end{basedtikz}

    Algo importante a destacar aquí es que el único estado de aceptación es $q_0$ ya que en los demás siempre hay cantidad impar de $aes$ o $bes$. Esto es relevante ya que es la esencia del siguiente ejercicio.

    \item Observe que para este ejercicio tenemos ocho posibilidades en total, bueno para ser exactos simplemente tenemos que hacer $7$ ya que en el anterior ya cubrimos el caso par de $aes$ y par de $bes$. La forma en que determinaremos que estados se vuelven de aceptación es considerando cadenas básicas que cumplen las condiciones y en que estado terminan.\\

    \textbf{Caso 1: }Impar de $aes$ o impar de $bes$. Note que en el autómata original $q_1,q_2$ y $q_3$ no son de aceptación ya que en todos $aes$ o $bes$ son impares, luego en este caso estos tres se vuelven de aceptación mientras que $q_0$ ya no lo es.
    \pagebreak
    \begin{basedtikz}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial] {$q_0$};
            \node (q1) [state, right of=q0, accepting] {$q_1$};
            \node (q2) [state, below of=q0, accepting] {$q_2$};
            \node (q3) [state, below of=q1, accepting] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge [bend left] node [right] {$b$} (q2)
            (q2) edge [bend left] node [left] {$b$} (q0)
            (q2) edge [bend left] node [above] {$a$} (q3)
            (q3) edge [bend left] node [below] {$a$} (q2)
            (q1) edge [bend left] node [right] {$b$} (q3)
            (q3) edge [bend left] node [left] {$b$} (q1);
        \end{tikzpicture}
    \end{basedtikz}

    \textbf{Caso 2: }Par de $aes$ o par de $bes$. Observe que el estado $q_0$ lo mantenemos como aceptación, luego note que la cadena $abb$ es aceptada por la condición y si seguimos este camino en el autómata $q_1$ debe ser de aceptación. De la misma manera $q_2$ tiene que ser de aceptación ya que la cadena $baa$ también es aceptada.
    \begin{basedtikz}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0, accepting] {$q_1$};
            \node (q2) [state, below of=q0, accepting] {$q_2$};
            \node (q3) [state, below of=q1] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge [bend left] node [right] {$b$} (q2)
            (q2) edge [bend left] node [left] {$b$} (q0)
            (q2) edge [bend left] node [above] {$a$} (q3)
            (q3) edge [bend left] node [below] {$a$} (q2)
            (q1) edge [bend left] node [right] {$b$} (q3)
            (q3) edge [bend left] node [left] {$b$} (q1);
        \end{tikzpicture}
    \end{basedtikz}

    \textbf{Caso 3: }Impar de $aes$ e impar de $bes$. Note que en la construcción anterior el estado $q_3$ no es de aceptación ya que es el único lugar donde $aes$ y $bes$ son impares, entonces para este caso ese va a ser nuestro único estado de aceptación.
    \begin{basedtikz}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, below of=q0] {$q_2$};
            \node (q3) [state, below of=q1, accepting] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge [bend left] node [right] {$b$} (q2)
            (q2) edge [bend left] node [left] {$b$} (q0)
            (q2) edge [bend left] node [above] {$a$} (q3)
            (q3) edge [bend left] node [below] {$a$} (q2)
            (q1) edge [bend left] node [right] {$b$} (q3)
            (q3) edge [bend left] node [left] {$b$} (q1);
        \end{tikzpicture}
    \end{basedtikz}

    \textbf{Caso 4: }Par de $aes$ e impar de $bes$. Observe que una cadena aceptada por estas condiciones es la cadena $baa$ y esta es aceptada en $q_2$ luego este tiene que ser de aceptación. Ahora note que ninguno de los demás es de aceptación ya que $q_0,q_1$ aceptan cadenas con un numero par de $bes$ y $q_3$ acepta cadenas con un numero impar de $aes$.
\begin{basedtikz}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, below of=q0, accepting] {$q_2$};
            \node (q3) [state, below of=q1] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge [bend left] node [right] {$b$} (q2)
            (q2) edge [bend left] node [left] {$b$} (q0)
            (q2) edge [bend left] node [above] {$a$} (q3)
            (q3) edge [bend left] node [below] {$a$} (q2)
            (q1) edge [bend left] node [right] {$b$} (q3)
            (q3) edge [bend left] node [left] {$b$} (q1);
        \end{tikzpicture}
    \end{basedtikz}
    \textbf{Caso 5: }Impar de $aes$ o par de $bes$. Por las $bes$ pares $q_0$ es de aceptación. Por el impar de $aes$, $q_1$ y $q_3$ son de aceptación.
    \begin{basedtikz}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0, accepting] {$q_1$};
            \node (q2) [state, below of=q0] {$q_2$};
            \node (q3) [state, below of=q1, accepting] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge [bend left] node [right] {$b$} (q2)
            (q2) edge [bend left] node [left] {$b$} (q0)
            (q2) edge [bend left] node [above] {$a$} (q3)
            (q3) edge [bend left] node [below] {$a$} (q2)
            (q1) edge [bend left] node [right] {$b$} (q3)
            (q3) edge [bend left] node [left] {$b$} (q1);
        \end{tikzpicture}
    \end{basedtikz}
    \textbf{Caso 6: }Impar de $aes$ y par de $bes$. Una cadena que debe ser aceptada es por ejemplo $abb$, luego el estado que la acepta es $q_1$, ademas note que los demás estados no son de aceptación ya que aceptan las cadenas $\lambda,b$ y $ab$ que no cumplen las condiciones.
    \begin{basedtikz}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial] {$q_0$};
            \node (q1) [state, right of=q0, accepting] {$q_1$};
            \node (q2) [state, below of=q0] {$q_2$};
            \node (q3) [state, below of=q1] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge [bend left] node [right] {$b$} (q2)
            (q2) edge [bend left] node [left] {$b$} (q0)
            (q2) edge [bend left] node [above] {$a$} (q3)
            (q3) edge [bend left] node [below] {$a$} (q2)
            (q1) edge [bend left] node [right] {$b$} (q3)
            (q3) edge [bend left] node [left] {$b$} (q1);
        \end{tikzpicture}
    \end{basedtikz}
    \textbf{Caso 7: }Par de $aes$ o Impar de $bes$.
    \pagebreak
    \begin{basedtikz}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, below of=q0, accepting] {$q_2$};
            \node (q3) [state, below of=q1, accepting] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge [bend left] node [right] {$b$} (q2)
            (q2) edge [bend left] node [left] {$b$} (q0)
            (q2) edge [bend left] node [above] {$a$} (q3)
            (q3) edge [bend left] node [below] {$a$} (q2)
            (q1) edge [bend left] node [right] {$b$} (q3)
            (q3) edge [bend left] node [left] {$b$} (q1);
        \end{tikzpicture}
    \end{basedtikz}

Observe que por ejemplo la condición del caso $7$ es la negación de la condición del caso $6$. Ademas los estados de aceptación del caso $6$ son de no aceptación en el caso $7$ y viceversa. Esto quedaría mas que nada como una mera curiosidad sino fuera por que posteriormente se mostrara que esta es una forma de construir autómatas para lenguajes que tienen una condición negativa. Primero se construirá el autómata que acepta la condición positiva y luego para aceptar la negación se cambian los estados de aceptación a no aceptación y viceversa.
\end{itemize}


\textbf{Punto 3: }
\begin{itemize}[label={✎}]
    \item Primero debemos forzar el camino para aceptar $01$ que es la cadena mínima.
    \begin{basedtikz}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node(q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge [bend left] node [above] {$0$} (q1)
        (q1) edge [bend left] node [above] {$1$} (q2);
        \end{tikzpicture}
    \end{basedtikz}
    Ahora observe la cadena puede empezar por unos arbitrarios, estos lo generamos por medio de un bucle en el estado inicial. Luego lo mismo pasa en $q_1$ pero con ceros. Por ultimo al estar ya en el estado de aceptación note que si sale un $0$ o un $1$ la cadena dejaría de ser de aceptada y uno estaría tentado a pensar que van a un estado limbo y que el autómata quedaría de la siguiente forma:
    \begin{basedtikz}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node(q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge [bend left] node [above] {$0$} (q1)
        (q0) edge [loop above] node [above] {$1$} ()
        (q1) edge [loop above] node [above] {$0$} ()
        (q1) edge [bend left] node [above] {$1$} (q2);
        \end{tikzpicture}
    \end{basedtikz}
Pero note que las cadenas $0101$ y $101101$ son cadenas validas pero no son aceptadas por el autómata. Esto se arregla fácilmente con añadir los bucles correspondientes desde el ultimo estado.
    \begin{basedtikz}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node(q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge node [above] {$0$} (q1)
        (q0) edge [loop above] node [above] {$1$} ()
        (q1) edge [loop above] node [above] {$0$} ()
        (q2) edge [bend left] node [below] {$0$} (q1)
        (q2) edge [bend left=60] node [below] {$1$} (q0)
        (q1) edge [bend left] node [above] {$1$} (q2);
            \end{tikzpicture}
        \end{basedtikz}
        \item Primero forzamos la mínima cadena par de unos que es $11$, luego realizamos la construcción para obtener cantidad par de unos y añadimos bucles de $0$ en todos los estados ya que estos no tienen restricción alguna.
        \begin{basedtikz}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node(q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge node [above] {$1$} (q1)
        (q0) edge [loop above] node [above] {$0$} ()
        (q1) edge [loop above] node [above] {$0$} ()
        (q2) edge [bend left] node [below] {$1$} (q1)
        (q1) edge [bend left] node [above] {$1$} (q2)
        (q2) edge [loop above] node [above] {$0$} ();
            \end{tikzpicture}
        \end{basedtikz}
        \item Al igual que hacíamos con las expresiones regulares, hacemos primero que se acepten todas las cadenas de longitud $4$ que son las mínimas y posteriormente por medio de un bucle se generaran todas las demás.
        \begin{basedtikz}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node(q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1] {$q_2$};
        \node (q3) [state, right of=q2] {$q_4$};
        \node (q4) [state, right of=q3, accepting] {$q_4$};
        \path[thick]
        (q0) edge node [above] {$0,1$} (q1)
        (q1) edge node [above] {$0,1$} (q2)
        (q2) edge node [above] {$0,1$} (q3)
        (q3) edge node [above] {$0,1$} (q4)
        (q4) edge [loop above] node [above] {$0,1$} ();
            \end{tikzpicture}
        \end{basedtikz}
        \item Nuevamente forzaremos el hecho de que hayan al menos dos unos seguidos, en el primer estado agregaremos un bucle de $0$ ya que estos pueden ser arbitrarios y en el ultimo un bucle $0,1$ ya que ahi ya se cumple la condición entonces da igual que salga después
        \begin{basedtikz}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node(q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge [bend left] node [above] {$1$} (q1)
        (q0) edge [loop above] node [above] {$0$} ()
        (q1) edge [bend left] node [below] {$0$} (q0)
        (q1) edge node [above] {$1$} (q2)
        (q2) edge [loop above] node [above] {$0,1$} ();
            \end{tikzpicture}
        \end{basedtikz}
        Note que agregamos una flecha de $q_1$ a $q_0$ con etiqueta $0$ ya que esto permite aceptar cadenas como $101011001$ que sin este no serian aceptadas.

        \item Observe que debemos construir el camino forzando a que halla por lo menos un $1$ entre dos ceros (no olvide que la cadena $\lambda$ es de aceptación en este lenguaje).
        \begin{basedtikz}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
                \node (q0) [state, initial, accepting] {$q_0$};
                \node (q1) [state, right of=q0] {$q_1$};
                \node (q2) [state, right of=q1] {$q_2$};
                \node (q3) [state, right of=q2, accepting] {$q_3$};
                \path[thick]
                (q0) edge [loop above] node [above] {$1$} ()
                (q0) edge node [above] {$0$} (q1)
                (q1) edge node [above] {$1$} (q2)
                (q2) edge [loop above] node [above] {$1$} ()
                (q2) edge node [above] {$0$} (q3)
                (q3) edge [bend left] node [below] {$1$} (q0);
            \end{tikzpicture}
        \end{basedtikz}
        Note que estamos acostumbrados a que cuando hacemos la construcción de pares el bucle se hace con los que queremos forzar a ser pares, pero en este caso se vuelve al estado inicial por medio de un $1$ es debido a que la condición de que no pueden haber $2$ ceros consecutivos.
        \item Note que podemos formar los respectivos bucles por separado ya que la cadena empieza por $01$ o por $101$ y luego estas se concatenan en cualquier  orden pero siempre son esos dos bloques.
        \begin{basedtikz}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
                \node (q0) [state, initial, accepting] {$q_0$};
                \node (q1) [state, below left of=q0] {$q_1$};
                \node (q2) [state, below right of=q0] {$q_2$};
                \node (q3) [state, above of=q0] {$q_3$};
                \path[thick]
                (q0) edge [bend left] node [left] {$0$} (q3)
                (q3) edge [bend left] node [right] {$1$} (q0)
                (q0) edge node [above] {$1$} (q1)
                (q1) edge node [below] {$0$} (q2)
                (q2) edge node [above] {$1$} (q0);
            \end{tikzpicture}
        \end{basedtikz}
        \item Este AFD fue construido por medio de un algoritmo que sera presentado en un capitulo posterior. Siendo sincero me fue imposible construir este AFD por mera inspección de la expresión regular.
        \pagebreak
        \begin{basedtikz}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, right of=q0, accepting] {$q_1$};
            \node (q2) [state, above right of=q1] {$q_2$};
            \node (q3) [state, below right of=q1, accepting] {$q_3$};
            \node (q4) [state, below right of=q2, accepting] {$q_4$};
            \node (q5) [state, right of=q4, accepting] {$q_5$}; 
            \path [thick]
            (q0) edge node [above] {$1$} (q1)
            (q1) edge [bend left] node [above] {$0$} (q2)
            (q1) edge [bend right] node [below] {$1$} (q3)
            (q2) edge [bend left] node [above] {$1$} (q4)
            (q4) edge [bend left] node [below] {$0$} (q2)
            (q3) edge [loop below] node [below] {$1$} ()
            (q3) edge [bend right] node [below] {$0$} (q4)
            (q4) edge [bend left] node [above] {$1$} (q5)
            (q5) edge [bend left] node [below] {$0$} (q4)
            (q5) edge [loop above] node [above] {$1$} ();
            \end{tikzpicture}
        \end{basedtikz}
\end{itemize}

\textbf{Punto 4:}
\begin{itemize}[label={✎}]
    \item Basta con forzar los bucles para cada elemento y el hecho de que todas las cadenas tienen la misma secuencia de elementos, $aes$ arbitrarias luego $bes$ arbitrarias y por ultimo $ces$ arbitrarias.
    \begin{basedtikz}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0, accepting] {$q_1$};
            \node (q2) [state, right of=q1, accepting] {$q_2$};
            \path[thick]
            (q0) edge [loop above] node [above] {$a$} () 
            (q1) edge [loop above] node [above] {$b$} ()
            (q2) edge [loop above] node [above] {$c$} ()
            (q0) edge node [above] {$b$} (q1) 
            (q1) edge node [above] {$c$} (q2)
            (q0) edge [bend right] node [below] {$c$} (q2);
        \end{tikzpicture}
    \end{basedtikz}
    \item Haremos una construcción por dos caminos distintos a partir de las cadenas mínimas. La primera es el camino que se forma con la cadena $a$.
    \begin{basedtikz}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, above right of=q0, accepting] {$q_1$};
        \node (q2) [state, below right of=q1, accepting] {$q_2$};
        \node (q3) [state, above right of=q1, accepting] {$q_3$};
        \node (q4) [state, below right of=q3, accepting] {$q_4$};
        \path[thick]
        (q0) edge [bend left] node [above] {$a$} (q1)
        (q1) edge [bend left] node [above] {$c$} (q2)
        (q2) edge [loop below] node [below] {$c$} ()
        (q1) edge [bend left=15] node [above] {$b$} (q4)
        (q1) edge [bend left] node [above] {$a$} (q3) 
        (q3) edge [loop above] node [above] {$a$} ()
        (q3) edge [bend left] node [above] {$b$} (q4)
        (q4) edge [loop right] node [right] {$b$} ();
        \end{tikzpicture}
    \end{basedtikz}
    Esta construcción se puede ver un tanto enredada pero si nos fijamos detalladamente simplemente se están considerando tres casos, primero las cadenas de la forma $ac^*$, segundo las cadenas de la forma $ab^*$ y por ultimo las $aa^+b^*$ (note que es necesario dividir estos dos últimos caminos así debido a la definición de los AFD).
    Ahora solo nos falta construir el camino para aceptar cadenas de la forma $b^*ca^*$.
    \begin{basedtikz}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, above right of=q0, accepting] {$q_1$};
        \node (q2) [state, below right of=q1, accepting] {$q_2$};
        \node (q3) [state, above right of=q1, accepting] {$q_3$};
        \node (q4) [state, below right of=q3, accepting] {$q_4$};
        \node (q5) [state, below of=q0] {$q_5$};
        \node (q6) [state, right of=q5, accepting] {$q_6$};
        \path[thick]
        (q0) edge [bend left] node [above] {$a$} (q1)
        (q1) edge [bend left] node [above] {$c$} (q2)
        (q2) edge [loop below] node [below] {$c$} ()
        (q1) edge [bend left=15] node [above] {$b$} (q4)
        (q1) edge [bend left] node [above] {$a$} (q3) 
        (q3) edge [loop above] node [above] {$a$} ()
        (q3) edge [bend left] node [above] {$b$} (q4)
        (q4) edge [loop right] node [right] {$b$} ()
        (q0) edge node [left] {$b$} (q5)
        (q5) edge [loop below] node [below] {$b$} ()
        (q5) edge node [below] {$c$} (q6)
        (q6) edge [loop below] node [below] {$a$} ()
        (q0) edge node [above] {$c$} (q6);
        \end{tikzpicture}
    \end{basedtikz}
    Note como forzamos la cadena mínima $c$ y usamos un estado extra para generar el bucle de $bes$ ya que si no lo hacemos y colocamos ese bucle en $q_0$ alteraríamos toda la parte superior del autómata. De esta forma ya estamos considerando todas las cadenas que son dadas aceptadas en el lenguaje.
    \item Observe que las cadenas mínimas son $ba$ y $ca$ luego basta con forzarlas y notar que ademas de las $aes$ arbitrarias iniciales siempre luego de una $b$ o $c$ va una $a$ y viceversa.
    \begin{basedtikz}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$}; 
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge [loop above] node [above] {$a$} ()
        (q0) edge node [above] {$b,c$} (q1)
        (q1) edge [bend left] node [above] {$a$} (q2)
        (q2) edge [bend left] node [below] {$b,c$} (q1);
        \end{tikzpicture}
    \end{basedtikz}
\end{itemize}

\textbf{Punto 5:} Primero es bastante evidente por la definición que se nos da que la expresión regular que determina a $L$ es:
$$(aa)^*(bbb)^*=\left(a^2\right)^*\left(b^3\right)^*$$
Ahora para la construcción del AFD $M$ tal que $L(M)=L$, basta con primero realizar la construcción para obtener una cantidad par de $aes$ y posteriormente agregamos un camino para aceptar cantidad de $bes$ que sean múltiplos de $3$ (esta construcción es muy parecida a la de pares solo que en vez de concatenar bloques $bb$ estamos concatenando bloques $bbb$).
    \begin{basedtikz}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, below of=q0] {$q_2$};
            \node (q3) [state, right of=q2] {$q_3$};
            \node (q4) [state, right of=q3, accepting] {$q_4$};
            \path [thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge node [left] {$b$} (q2)
            (q2) edge node [above] {$b$} (q3)
            (q3) edge node [above] {$b$} (q4)
            (q4) edge [bend left=45] node [below] {$b$} (q2);
        \end{tikzpicture}
    \end{basedtikz}
    Uno podría pensar que para hacer que se aceptaran esos bloques de $bbb$ sobra ese estado final y se puede ahorrar haciendo que vaya una flecha de $q_3$ a $q_0$ con la etiqueta $b$, pero note que eso causaría que las cadenas de la forma $(bbb)^*(aa)^*$ fueran aceptadas lo cual no es contemplado dentro del lenguaje.
    
    $\hfill \blacklozenge$

    \section{Autómatas finitos no-deterministas (AFN)} 

  A continuación construiremos AFN los cuales no tienen las mismas restricciones que los AFD y por tanto son bastante mas sencillos de construir, eso si algo de vital importancia es que al igual que en los AFD debemos tener cuidado de no construir caminos que acepten cadenas que no son contempladas por el lenguaje.\\

  \textbf{Punto 1:}

  \begin{itemize}[label={✎}]

        \item Tenemos que asegurar que toda cadena empiece por una $a$, luego simplemente generamos los dos bucles necesarios uno para $aes$ arbitrarias y el otro para bloques $ab$.
        \begin{basedtikz}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
               \node (q0) [state, initial] {$q_0$}; 
               \node (q1) [state, right of=q0, accepting] {$q_1$};
               \node (q2) [state, right of=q1] {$q_2$};
               \path[thick]
               (q0) edge node [above] {$a$} (q1)
               (q1) edge [loop above] node [above] {$a$} ()
               (q1) edge [bend left] node [above] {$a$} (q2)
               (q2) edge [bend left] node [below] {$b$} (q1);
            \end{tikzpicture}
        \end{basedtikz}
        Observe que este es un AFN ya que hay dos flechas con etiqueta $a$ saliendo desde $q_1$.
        \item Para la construcción forzamos la cadena mínima $aa$ junto a el bucle de $aes$ inicial.
        \pagebreak
        \begin{basedtikz}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
               \node (q0) [state, initial] {$q_0$}; 
               \node (q1) [state, right of=q0] {$q_1$};
               \node (q2) [state, right of=q1, accepting] {$q_2$};
               \node (q3) [state, below of=q1] {$q_3$};
               \path[thick]
               (q0) edge node [above] {$a$} (q1)
               (q1) edge [loop above] node [above] {$a$} ()
               (q1) edge node [above] {$a$} (q2)
               (q1) edge node [left] {$b$} (q3)
               (q3) edge [loop below] node [below] {$b$} ()
               (q3) edge [bend right] node [below] {$a$} (q2);  
            \end{tikzpicture}
        \end{basedtikz}
        Note que las $bes$ intermedias las agregamos por medio de un estado extra generando un camino nuevo.
        \item Basta con construir un camino para las cadenas mínimas $a$ y $b$, luego construimos dos caminos extra para aceptar $a^*b$ y $b^*a$ respectivamente.
        \begin{basedtikz}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
               \node (q0) [state, initial] {$q_0$}; 
               \node (q1) [state, above right of=q0] {$q_1$}; 
               \node (q2) [state, below right of=q0] {$q_2$};
               \node (q3) [state, below right of=q1, accepting] {$q_3$};
               \path[thick]
               (q0) edge node [above] {$a,b$} (q3)
               (q0) edge [bend left] node [above] {$a$} (q1)
               (q1) edge [bend left] node [above] {$b$} (q3)
               (q0) edge [bend right] node [below] {$b$} (q2)
               (q2) edge [bend right] node [below] {$a$} (q3)
               (q1) edge [loop above] node [above] {$a$} ()
               (q2) edge [loop below] node [below] {$b$} ();
            \end{tikzpicture}
        \end{basedtikz}
        \item Forzaremos las $bes$ arbitrarias en el primer estado y luego generamos los caminos correspondientes para la concatenación de $ab$ y $ba$.
        \pagebreak
        \begin{basedtikz}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
               \node (q0) [state, initial, accepting] {$q_0$}; 
               \node (q1) [state, above right of=q0] {$q_1$}; 
               \node (q2) [state, below right of=q0] {$q_2$};
               \node (q3) [state, below right of=q1, accepting] {$q_3$};
               \path[thick]
               (q0) edge [loop above] node [above] {$b$} ()
               (q0) edge [bend left=15] node [above] {$a$} (q1)
               (q1) edge [bend left] node [above] {$b$} (q3)
               (q3) edge [bend left] node [below] {$a$} (q1)
               (q0) edge [bend right=15] node [below] {$b$} (q2)
               (q2) edge [bend right] node [below] {$a$} (q3)
               (q3) edge [bend right] node [above] {$b$} (q2);
            \end{tikzpicture}
        \end{basedtikz}
        \item Observe que el lenguaje es exactamente igual al anterior a excepción de que ahora las cadenas pueden terminar en un numero arbitrario de $aes$, pero como estamos construyendo un AFN basta con notar que agregando un nuevo estado que sea de aceptación con un bucle de $aes$ es suficiente.
        \begin{basedtikz}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
               \node (q0) [state, initial, accepting] {$q_0$}; 
               \node (q1) [state, above right of=q0] {$q_1$}; 
               \node (q2) [state, below right of=q0] {$q_2$};
               \node (q3) [state, below right of=q1, accepting] {$q_3$};
               \node (q4) [state, right of=q3, accepting] {$q_4$};
               \path[thick]
               (q0) edge [loop above] node [above] {$b$} ()
               (q0) edge [bend left=15] node [above] {$a$} (q1)
               (q1) edge [bend left] node [above] {$b$} (q3)
               (q3) edge [bend left] node [below] {$a$} (q1)
               (q0) edge [bend right=15] node [below] {$b$} (q2)
               (q2) edge [bend right] node [below] {$a$} (q3)
               (q3) edge [bend right] node [above] {$b$} (q2)
               (q3) edge node [above] {$a$} (q4)
               (q4) edge [loop above] node [above] {$a$} ();
            \end{tikzpicture}
        \end{basedtikz}
    \end{itemize}

    \textbf{Punto 2:}  

    \begin{itemize}[label={✎}]
        \item Simplemente construimos los caminos para aceptar $01$ y $001$ por separado.
        \begin{basedtikz}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q1) [state, above right of=q0] {$q_1$};
            \node (q2) [state, below of=q0] {$q_2$};
            \node (q3) [state, right of=q2] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$0$} (q1)
            (q1) edge [bend left] node [below] {$1$} (q0)
            (q0) edge node [left] {$0$} (q2)
            (q2) edge node [below] {$0$} (q3)
            (q3) edge node [above] {$1$} (q0);
            \end{tikzpicture}
        \end{basedtikz}
        \item Nuevamente basta con construir los caminos correspondientes a $01^*0$ y $10^*$.
        
        \begin{basedtikz}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, below of=q0] {$q_2$};
            \path[thick]
            (q0) edge [bend left] node [above] {$0$} (q1)
            (q1) edge [bend left] node [below] {$0$} (q0)
            (q0) edge [bend right] node [left] {$1$} (q2)
            (q2) edge [bend right] node [right] {$0$} (q0)
            (q2) edge [loop below] node [below] {$0$} ()
            (q0) edge [loop above] node [above] {$1$} ()
            (q1) edge [loop above] node [above] {$1$} ();
            \end{tikzpicture}
        \end{basedtikz}

        Observe que es necesario incluir ese bucle con etiqueta $1$ para aceptar cuando solo hay unos en la expresión $10^*$ (es decir en el caso donde $1$ se concatena con $\lambda$). 

        \item Construimos los caminos de las cadenas $10^*1$ y $01$.
        \begin{basedtikz}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, right of=q1, accepting] {$q_2$};
            \node (q3) [state, above of=q1] {$q_3$};
            \node (q4) [state, below of=q0] {$q_4$};
            \path[thick]
            (q0) edge node [above] {$0$} (q1)
            (q1) edge node [above] {$1$} (q2)
            (q0) edge [bend left] node [above] {$1$} (q3)
            (q3) edge [bend left] node [above] {$1$} (q2)
            (q3) edge [loop above] node [above] {$0$} ()
            (q0) edge node [left] {$1$} (q4)
            (q4) edge node [below] {$0$} (q1)
            (q4) edge [loop below] node [below] {$1$} ();
            \end{tikzpicture}
        \end{basedtikz}
        Note que usamos un estado adicional para construir el camino para aceptar $1^*01$.
    \end{itemize}

    $\hfill \blacklozenge$

    \section{Equivalencia computacional entre los AFD y los AFN}

    En la anterior sección se hizo bastante notorio como la construcción de AFN es mucho mas sencilla que la de un AFD. En esta sección se nos enseña que por medio de un proceso podemos convertir cualquier AFN en un AFD, algo que resulta extremadamente conveniente pero aveces el proceso es algo tedioso.\\ 

    \textbf{Punto 1:}\\ 
    A continuación en cada AFD que construyamos omitiremos los estados inútiles.\\

    \begin{itemize}[label={✎}]
        \item Primero realicemos la extensión de la tabla.
       
       \begin{center}
               \begin{tabular}{|c|c|c|}
        \hline
        $\Delta$ & $a$ & $b$\\
        \hline 
        $q_0$ & $\varnothing$ & $\{q_1,q_2\}$ \\ 
        \hline
        $q_1$ &$\{q_0\}$ &$\varnothing$ \\ 
        \hline
        $q_2$& $\{q_3\}$& $\varnothing$ \\ 
        \hline
        $q_3$&$\varnothing$&$\{q_0\}$\\ 
        \hline
    
        $\{q_1,q_2\}$&$\{q_0,q_3\}$&$\varnothing$\\ 
        \hline
        $\{q_0,q_3\}$&$\varnothing$&$\{q_0,q_1,q_2\}$\\
        \hline
        $\{q_0,q_1,q_2\}$&$\{q_0,q_3\}$&$\{q_1,q_2\}$\\ 
        \hline
        \end{tabular}
       \end{center}
       
        En el AFN original teníamos que los estados de aceptación eran $q_0$ y $q_3$ luego en el AFD los estados de aceptación son todos aquellos que contengan alguno de estos dos. Por  estética definiremos $q_4:=\{q_1,q_2\},q_5:=\{q_0,q_3\}$ y $q_6:=\{q_0,q_1,q_2\}$. 
        \begin{basedtikz}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q4) [state, right of=q0] {$q_4$};
            \node (q5) [state, right of=q4, accepting] {$q_5$};
            \node (q6) [state, right of=q5, accepting] {$q_6$};
            \path[thick]
            (q0) edge node [above] {$b$} (q4)
            (q4) edge node [above] {$a$} (q5)
            (q5) edge [bend left] node [above] {$b$} (q6)
            (q6) edge [bend left] node [below] {$a$} (q5)
            (q6) edge [bend left=60] node [below] {$b$} (q4);
            \end{tikzpicture}
        \end{basedtikz}

        \item Realicemos la extensión de la tabla.

        \begin{center}
            \begin{tabular}{|c|c|c|}
        \hline
        $\Delta$ & $a$ & $b$\\
        \hline 
        $q_0$ & $\varnothing$ & $\{q_1,q_2\}$ \\ 
        \hline
        $q_1$ &$\{q_0,q_1\}$ &$\varnothing$ \\ 
        \hline
        $q_2$& $\{q_3\}$& $\varnothing$ \\ 
        \hline
        $q_3$&$\varnothing$&$\{q_0\}$\\ 
        \hline
        \hline
        $\{q_1,q_2\}$&$\{q_0,q_1,q_3\}$&$\varnothing$\\ 
        \hline
        $\{q_0,q_1\}$&$\{q_0,q_1\}$&$\{q_1,q_2\}$\\ 
        \hline
        $\{q_0,q_1,q_3\}$&$\{q_0,q_1\}$&$\{q_0,q_1,q_2\}$\\
        \hline
        $\{q_0,q_1,q_2\}$&$\{q_0,q_1,q_3\}$&$\{q_1,q_2\}$\\ 
        \hline       
        \end{tabular}   
        \end{center}
        Nuevamente los estados de aceptación del AFD son todos aquellos que contienen $q_0$ o $q_3$. Ahora definimos $q_4:=\{q_1,q_2\},q_5:=\{q_0,q_1,q_3\},q_6:=\{q_0,q_1\}$ y $q_7:=\{q_0,q_1,q_2\}$.

        \begin{basedtikz}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q4) [state, right of=q0] {$q_4$};
            \node (q5) [state, right of=q4, accepting] {$q_5$};
            \node (q6) [state, right of=q5, accepting] {$q_6$};
            \node (q7) [state, below of=q5, accepting] {$q_7$};
            \path[thick]
            (q0) edge node [above] {$b$} (q4)
            (q4) edge node [above] {$a$} (q5)
            (q5) edge node [above] {$a$} (q6)
            (q6) edge [bend right=45] node [above] {$b$} (q4)
            (q6) edge [loop below] node [below] {$a$} ()
            (q5) edge [bend right] node [left] {$b$} (q7)
            (q7) edge [bend right] node [right] {$a$} (q5)
            (q7) edge [bend left] node [below] {$b$} (q4);
            \end{tikzpicture}
        \end{basedtikz}

        \item Realicemos la extensión de la tabla.
        \begin{center}
             \begin{tabular}{|c|c|c|}
        \hline
        $\Delta$ & $a$ & $b$\\
        \hline 
        $q_0$ & $\varnothing$ & $\{q_0,q_1\}$\\ 
        \hline
        $q_1$ &$\{q_1,q_2\}$ &$\varnothing$ \\ 
        \hline
        $q_2$& $\varnothing$& $\{q_1\}$ \\  
        \hline
        \hline
        $\{q_0,q_1\}$&$\{q_1,q_2\}$&$\{q_0,q_1\}$\\
        \hline
        $\{q_1,q_2\}$&$\{q_1,q_2\}$&$\{q_1\}$\\ 
        \hline             
        \end{tabular}   
        \end{center}
        Los estados de aceptación serán aquellos que contengan $q_1$ y $q_2$, ademas definimos $q_3:=\{q_0,q_1\}$ y $q_4:=\{q_1,q_2\}$.
        \begin{basedtikz}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q3) [state, right of=q0, accepting] {$q_3$};
            \node (q4) [state, right of=q3, accepting] {$q_4$};
            \node (q1) [state, right of=q4, accepting] {$q_1$};
            \path[thick]
            (q0) edge node [above] {$b$} (q3)
            (q3) edge node [above] {$a$} (q4)
            (q3) edge [loop above] node [above] {$b$} ()
            (q4) edge [loop above] node [above] {$a$} ()
            (q4) edge [bend left] node [above] {$b$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q4);
            \end{tikzpicture}
        \end{basedtikz}

        \item Creo que ya es evidente que es lo primero que haremos.
      \begin{center}
          \begin{tabular}{|c|c|c|}
        \hline
        $\Delta$ & $a$ & $b$\\
        \hline 
        $q_0$ & $\{q_0,q_1\}$ & $\varnothing$\\ 
        \hline
        $q_1$ &$\varnothing$ &$\{q_2\}$ \\ 
        \hline
        $q_2$& $\{q_0,q_1\}$& $\varnothing$ \\  
        \hline
        \hline
        $\{q_0,q_1\}$&$\{q_0,q_1\}$&$\{q_2\}$\\
        \hline           
        \end{tabular}   
      \end{center}
        Los estados de aceptación son aquellos que contienen $q_0$ y $q_2$, ademas definimos $q_3:=\{q_0,q_1\}$.
        \pagebreak
        \begin{basedtikz}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q3) [state, right of=q0, accepting] {$q_3$};
            \node (q2) [state, right of=q3, accepting] {$q_2$};
            \path[thick]
            (q0) edge node [above] {$a$} (q3)
            (q3) edge [loop above] node [above] {$a$} ()
            (q3) edge [bend left] node [above] {$b$} (q2)
            (q2) edge [bend left] node [below] {$a$} (q3);
            \end{tikzpicture}
        \end{basedtikz}
    \end{itemize}

    \textbf{Punto 2:}\\

Note primero como ayuda que la expresión regular que describe $L_3$ es:
$$(0\cup1)^*1(0\cup1)^2$$
 Luego el AFN que describe este lenguaje surge de una construcción bastante natural solo observando la expresión regular.
 
 \begin{basedtikz}
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
    \node (q0) [state, initial] {$q_0$};
    \node (q1) [state, right of=q0] {$q_1$};
    \node (q2) [state, right of=q1] {$q_2$};
    \node (q3) [state, right of=q2, accepting] {$q_3$};
    \path[thick]
    (q0) edge [loop above] node [above] {$0,1$} ()
    (q0) edge node [above] {$1$} (q1)
    (q1) edge node [above] {$0,1$} (q2)
    (q2) edge node [above] {$0,1$} (q3);
    \end{tikzpicture}
\end{basedtikz}

Ahora realicemos la extensión de la tabla.

\begin{center}
          \begin{tabular}{|c|c|c|}
        \hline
        $\Delta$ & $0$ & $1$\\
        \hline 
        $q_0$ & $\{q_0\}$ & $\{q_0,q_1\}$\\ 
        \hline
        $q_1$ &$\{q_2\}$ &$\{q_2\}$ \\ 
        \hline
        $q_2$& $\{q_3\}$& $\{q_3\}$ \\  
        \hline
        $q_3$& $\varnothing$& $\varnothing$ \\
        \hline
        \hline 
        $\{q_0,q_1\}$&$\{q_0,q_2\}$&$\{q_0,q_1,q_2\}$\\
        \hline
        $\{q_0,q_2\}$&$\{q_0,q_3\}$&$\{q_0,q_1,q_3\}$\\
        \hline
        $\{q_0,q_1,q_2\}$&$\{q_0,q_2,q_3\}$&$\{q_0,q_1,q_2,q_3\}$\\
        \hline
        $\{q_0,q_3\}$&$\{q_0\}$&$\{q_0,q_1\}$\\
        \hline
        $\{q_0,q_1,q_3\}$&$\{q_0,q_2\}$&$\{q_0,q_1,q_2\}$\\
        \hline
        $\{q_0,q_2,q_3\}$&$\{q_0,q_3\}$&$\{q_0,q_1,q_3\}$\\
        \hline
        $\{q_0,q_1,q_2,q_3\}$&$\{q_0,q_2,q_3\}$&$\{q_0,q_1,q_2,q_3\}$\\
        \hline
        \end{tabular}
      \end{center}
Ahora observe que en el AFD los estados de aceptación serán aquellos que contengan a $q_3$, ademas definimos $q_4:=\{q_0,q_1\},q_5:=\{q_0,q_2\},q_6:=\{q_0,q_1,q_2\},q_7:=\{q_0,q_3\},q_8:=\{q_0,q_1,q_3\},q_9:=\{q_0,q_2,q_3\}$ y $q_{10}:=\{q_0,q_1,q_2,q_3\}$.
\pagebreak
\begin{basedtikz}
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
    \node (q0) [state, initial] {$q_0$};
    \node (q4) [state, right of=q0] {$q_4$};
    \node (q5) [state, right of=q4] {$q_5$};
    \node (q7) [state, right of=q5, accepting] {$q_7$};
    \node (q6) [state, below of=q4] {$q_6$};
    \node (q8) [state, right of=q6, accepting] {$q_8$};
    \node (q9) [state, right of=q8, accepting] {$q_9$};
    \node (q10) [state, below of=q8, accepting] {$q_{10}$};
    \path[thick]
    (q0) edge [loop below] node [below] {$0$} ()
    (q0) edge node [above] {$1$} (q4)
    (q4) edge node [above] {$0$} (q5)
    (q4) edge node [left] {$1$} (q6)
    (q5) edge node [above] {$0$} (q7)
    (q5) edge [bend left] node [right] {$1$} (q8)
    (q7) edge [bend right=60] node [above] {$0$} (q0)
    (q7) edge [bend right=45] node [above] {$1$} (q4)
    (q6) edge [bend right=45] node [below] {$0$} (q9)
    (q6) edge [bend right] node [below] {$1$} (q10)
    (q8) edge [bend left] node [left] {$0$} (q5)
    (q8) edge node [above] {$1$} (q6)
    (q9) edge node [right] {$0$} (q7)
    (q9) edge node [above] {$1$} (q8)
    (q10) edge [bend right] node [below] {$0$} (q9)
    (q10) edge [loop below] node [below] {$1$} ();
    \end{tikzpicture}
\end{basedtikz}

\textbf{Punto 3:}
\begin{proof}
Dados $q\in Q$ y $u,v\in\Sigma^*$ realizaremos recursión sobre la cadena $v$.\\
Si $v=\lambda$ es evidente por la definición de la extensión de $\delta$ que:
$$\delta(\delta(q,u),\lambda)=\delta(q,u)=\delta(q,u\lambda)$$
Como tenemos el caso base consideremos que nuestra hipótesis recursiva se cumple es decir:
$$\delta(q,uv)=\delta(\delta(q,u),v)$$ 
Ahora veamos que ocurre con $va$ donde $a\in\Sigma$
\begin{align*}
      \delta(q,uva)&=\delta(\delta(q,uv),a)&(\text{Definición de la extensión de }\delta)\\
      &=\delta(\delta(\delta(q,u),v),a)&(\text{Hipótesis recursiva})\\
      &=\delta(\delta(q,u),va)&(\text{Definición de la extensión de }\delta)
  \end{align*} 
De esta manera concluimos que la propiedad se cumple. 

\end{proof}
\textbf{Punto 4:}
\begin{proof}
Dados $q\in Q$ y $u,v\in\Sigma^*$ procederemos igual que en el punto anterior.\\
Si $v=\lambda$ por la definición de la extensión de $\Delta$ se tiene que:
$$\Delta(\Delta(q,u),\lambda)=\bigcup_{p\in\Delta(q,u)}\Delta(p,\lambda)=\bigcup_{p\in\Delta(q,u)}\{p\}=\Delta(q,u)=\Delta(q,u\lambda)$$ 
Como tenemos el caso base consideremos que nuestra hipótesis recursiva se cumple es decir:
$$\Delta(q,uv)=\Delta(\Delta(q,u),v)$$ 
Ahora veamos que ocurre con $va$ donde $a\in\Sigma$ 
\begin{align*}
    \Delta(q,uva)&=\Delta(\Delta(q,uv),a)&(\text{Definición de la extensión de }\Delta)\\
      &=\Delta(\Delta(\Delta(q,u),v),a)&(\text{Hipótesis recursiva})\\
      &=\Delta(\Delta(q,u),va)&(\text{Definición de la extensión de }\Delta)  
  \end{align*} 
De esta manera concluimos que la propiedad se cumple. 
 
\end{proof}

$\hfill \blacklozenge$

\section{Autómatas con transiciones \texorpdfstring{\boldmath$\lambda$}{lambda} (AFN-\texorpdfstring{\boldmath$\lambda$}{lambda})} 

Si bien previamente habíamos observado como los AFN eran bastante fáciles de construir, en esta sección nos daremos cuenta de que existe incluso construcciones aun mas sencillas, que son los AFN-$\lambda$. En esta sección veremos como construirlos y luego observaremos su relevancia.\\

\textbf{Punto 1:}

\begin{itemize}[label={✎}]
    \item Para este autómata realizaremos una construcción en serie, concatenando los autómatas respectivos de cada parte del lenguaje, note que $a$ es la mínima cadena de aceptación.
    \begin{basedtikz}
       \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
       \node (q0) [state, initial] {$q_0$};
       \node (q1) [state, below of=q0] {$q_1$};
       \node (q2) [state, right of=q0] {$q_2$};
       \node (q3) [state, right of=q2] {$q_3$};
       \node (q4) [state, right of=q3, accepting] {$q_4$};
       \path[thick]
       (q0) edge [loop above] node [above] {$b$} ()
       (q0) edge [bend right] node [left] {$a$} (q1)
       (q1) edge [bend right] node [right] {$b$} (q0)
       (q0) edge node [above] {$\lambda$} (q2)
       (q2) edge node [above] {$a$} (q3)
       (q3) edge [loop above] node [above] {$b$} ()
       (q3) edge node [above] {$\lambda$} (q4)
       (q4) edge [loop above] node [above] {$a$} ();
       \end{tikzpicture} 
    \end{basedtikz}

    \item Basta con realizar una construcción en paralelo para cada expresión de la unión. Es decir construimos un AFD para $ab^*,ba^*$ y $b(ab\cup ba)^*$ respectivamente y luego realizamos la construcción en paralelo.
    \pagebreak
    \begin{basedtikz}
       \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
       \node (q0) [state, initial] {$q_0$};
       \node (q1) [state, right of=q0] {$q_1$};
       \node (q2) [state, right of=q1, accepting] {$q_2$};
       \node (q3) [state, above of=q1] {$q_3$};
       \node (q4) [state, right of=q3, accepting] {$q_4$};
       \node (q5) [state, below of=q1] {$q_5$};
       \node (q6) [state, right of=q5, accepting] {$q_6$};
       \node (q7) [state, right of=q6] {$q_7$};
       \node (q8) [state, below of=q6] {$q_6$};
       \path[thick]
       (q0) edge node [above] {$\lambda$} (q1)
       (q0) edge node [above] {$\lambda$} (q3)
       (q0) edge node [below] {$\lambda$} (q5)
       (q1) edge node [above] {$b$} (q2)
       (q2) edge [loop right] node [right] {$a$} ()
       (q3) edge node [above] {$a$} (q4)
       (q4) edge [loop right] node [right] {$b$} ()
       (q5) edge node [above] {$b$} (q6)
       (q6) edge [bend left] node [above] {$a$} (q7)
       (q7) edge [bend left] node [below] {$b$} (q6)
       (q6) edge [bend right] node [left] {$b$} (q8)
       (q8) edge [bend right] node [right] {$a$} (q6);
       \end{tikzpicture} 
    \end{basedtikz}

    \item Nuevamente realizaremos una construcción en serie, note que la cadena $\lambda$ es la mínima que se acepta.

    \begin{basedtikz}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
         \node (q0) [state, initial] {$q_0$};
         \node (q1) [state, below of=q0] {$q_1$};
         \node (q2) [state, right of=q1] {$q_2$};
         \node (q3) [state, right of=q0] {$q_3$};
         \node (q4) [state, right of=q3] {$q_4$};
         \node (q5) [state, above of=q4] {$q_5$};
         \node (q6) [state, below of=q4] {$q_6$};
         \node (q7) [state, right of=q4, accepting] {$q_7$};
         \path[thick]
         (q0) edge [loop above] node [above] {$a$} ()
         (q0) edge node [left] {$a$} (q1)
         (q1) edge node [below] {$b$} (q2)
         (q2) edge node [above] {$a$} (q0)
         (q0) edge node [above] {$\lambda$} (q3)
         (q3) edge [loop above] node [above] {$b$} ()
         (q3) edge node [above] {$\lambda$} (q4)
         (q4) edge [bend left] node [left] {$a$} (q5)
         (q5) edge [bend left] node [right] {$b$} (q4)
         (q4) edge [bend left] node [right] {$b$} (q6)
         (q6) edge [bend left] node [left] {$a$} (q4)
         (q4) edge node [above] {$\lambda$} (q7)
         (q7) edge [loop above] node [above] {$a$} ();
        \end{tikzpicture}
    \end{basedtikz}
\end{itemize}

\textbf{Punto 2:}

\begin{itemize}[label={✎}]
    \item El único autómata que puede resultar un poco complicado de construir es el de la expresión inicial $(1\cup01\cup001)^*$ pero basta con 3 estados, luego simplemente es realizar una construcción en serie.
    \pagebreak
    \begin{basedtikz}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
         \node (q0) [state, initial] {$q_0$};
         \node (q1) [state, below of=q0] {$q_1$};
         \node (q2) [state, right of=q1] {$q_2$};
         \node (q3) [state, right of=q0] {$q_3$};  
         \node (q4) [state, right of=q3] {$q_4$}; 
         \node (q5) [state, right of=q4, accepting] {$q_5$};
         \path[thick]
         (q0) edge [loop above] node [above] {$1$} ()
         (q0) edge [bend right] node [left] {$0$} (q1)
         (q1) edge [bend right] node [right] {$1$} (q0)
         (q1) edge node [below] {$0$} (q2)
         (q2) edge node [above] {$1$} (q0)
         (q0) edge node [above] {$\lambda$} (q3)
         (q3) edge [loop above] node [above] {$0$} ()
         (q3) edge node [above] {$\lambda$} (q4)
         (q4) edge [loop above] node [above] {$1$} ()
         (q4) edge node [above] {$0$} (q5)
         (q5) edge [loop above] node [above] {$0$} ();
        \end{tikzpicture}
    \end{basedtikz}

    \item Nuevamente una construcción en serie basta.

    \begin{basedtikz}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
         \node (q0) [state, initial] {$q_0$};
         \node (q1) [state, right of=q0] {$q_1$};
         \node (q2) [state, right of=q1] {$q_2$};
         \node (q3) [state, below of=q2] {$q_3$};  
         \node (q4) [state, left of=q3] {$q_4$}; 
         \node (q5) [state, right of=q2] {$q_5$};
         \node (q6) [state, above of=q5] {$q_6$};
         \node (q7) [state, below of=q5] {$q_7$};
         \node (q8) [state, right of=q5, accepting] {$q_8$};
         \path[thick]
         (q0) edge node [above] {$0$} (q1)
         (q1) edge [loop above] node [above] {$0$} ()
         (q1) edge node [above] {$1$} (q2)
         (q2) edge node [right] {$0$} (q3)
         (q3) edge node [below] {$1$} (q4)
         (q4) edge node [above] {$0$} (q2)
         (q2) edge node [above] {$\lambda$} (q5)
         (q5) edge [bend left] node [left] {$0$} (q6)
         (q6) edge [bend left] node [right] {$1$} (q5)
         (q5) edge [bend left] node [right] {$1$} (q7)
         (q7) edge [bend left] node [left] {$0$} (q5)
         (q5) edge node [above] {$1$} (q8)
         (q8) edge [loop above] node [above] {$1$} ();
        \end{tikzpicture}
    \end{basedtikz}

    \item Observe que en este caso usaremos tanto la construcción en paralelo como la construcción en serie ya que uno de los caminos es relativamente complicado de construir pero con esta construcción es mucho mas sencillo.
    \pagebreak
    \begin{basedtikz}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
         \node (q0) [state, initial] {$q_0$};
         \node (q1) [state, above right of=q0] {$q_1$};
         \node (q2) [state, right of=q1] {$q_2$};
         \node (q3) [state, right of=q2, accepting] {$q_3$};
         \node (q4) [state, below right of=q0] {$q_4$};
         \node (q5) [state, right of=q4] {$q_5$};
         \node (q6) [state, below of=q5] {$q_6$};
         \node (q7) [state, right of=q5] {$q_7$};
         \node (q8) [state, right of=q7, accepting] {$q_8$};
         \node (q9) [state, above of=q8] {$q_9$};
         \node (q10) [state, below of=q8] {$q_{10}$};
         \path[thick]
         (q0) edge [bend left] node [above] {$\lambda$} (q1)
         (q1) edge node [above] {$1$} (q2)
         (q2) edge node [above] {$0$} (q3)
         (q3) edge [bend right=45] node [above] {$1$} (q1)
         (q0) edge [bend right] node [below] {$\lambda$} (q4)
         (q4) edge [loop above] node [above] {$1$} ()
         (q4) edge node [above] {$\lambda$} (q5)
         (q5) edge [loop above] node [above] {$1$} ()
         (q5) edge [bend right] node [left] {$1$} (q6)
         (q6) edge [bend right] node [right] {$0$} (q5)
         (q5) edge node [above] {$0$} (q7)
         (q7) edge [loop above] node [above] {$0$} ()
         (q7) edge node [above] {$\lambda$} (q8)
         (q8) edge [bend left] node [left] {$0$} (q9)
         (q9) edge [bend left] node [right] {$1$} (q8)
         (q8) edge [bend left] node [right] {$1$} (q10)
         (q10) edge [bend left] node [left] {$0$} (q8);
        \end{tikzpicture}
    \end{basedtikz}
\end{itemize}

$\hfill \blacklozenge$

\section{Equivalencia computacional entre los AFN-\texorpdfstring{\boldmath$\lambda$}{lambda} y los AFN}

Previamente habíamos observado como si construíamos un AFN para aceptar un lenguaje regular, podíamos por medio de un algoritmo convertirlo en un AFD. En esta sección observaremos como podemos convertir un AFN-$\lambda$ en un AFN.\\

\textbf{Punto 1: }Primero hallemos la $\lambda$-clausura de cada estado:
\begin{align*}
    \lambda[q_0]&=\{q_0,q_1,q_2\}\\
    \lambda[q_1]&=\{q_1,q_2\}\\
    \lambda[q_2]&=\{q_2\}
\end{align*}
Observe que en el autómata original el único estado de aceptación es $q_2$, luego como esta pertenece a $\lambda[q_0],\lambda[q_1]$ y $\lambda[q_2]$, $q_0,q_1$ y $q_2$ son de aceptación en el AFN.
\begin{basedtikz}
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial, accepting] {$q_0$};
        \node (q1) [state, right of=q0, accepting] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge [loop above] node [above] {$a$} ()
        (q1) edge [loop above] node [above] {$b$} ()
        (q2) edge [loop above] node [above] {$a$} ();
    \end{tikzpicture}
\end{basedtikz}
Antes de hacer la inspección para hallar el AFN, es importante tener en cuenta que las flechas ya existentes con etiquetas distintas a $\lambda$ se mantienen. Como ejemplo de inspección observe que desde $q_0$, por medio de las etiquetas $a$ y $b$ se puede llegar tanto a $q_1$ como a $q_2$ haciendo las concatenaciones $a\lambda,a\lambda\lambda,\lambda b,\lambda b\lambda$ respectivamente. El AFN obtenido es el siguiente:
\begin{basedtikz}
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial, accepting] {$q_0$};
        \node (q1) [state, right of=q0, accepting] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge [loop above] node [above] {$a$} ()
        (q1) edge [loop above] node [above] {$b$} ()
        (q2) edge [loop above] node [above] {$a$} ()
        (q0) edge node [above] {$a,b$} (q1)
        (q1) edge node [above] {$a,b$} (q2)
        (q0) edge [bend right=45] node [below] {$a,b$} (q2);
    \end{tikzpicture}
\end{basedtikz}

\textbf{Punto 2: }Primero hallemos la $\lambda$-clausura de cada estado:
\begin{align*}
    \lambda[q_0]&=\{q_0,q_3\}\\
    \lambda[q_1]&=\{q_1,q_2\}\\
    \lambda[q_2]&=\{q_2\}\\
    \lambda[q_3]&=\{q_3\}\\ 
    \lambda[q_4]&=\{q_4\}
\end{align*}
$q_2$ y $q_4$ son de aceptación en el original, por tanto observando las $\lambda$-clausuras, $q_1,q_2$ y $q_4$ son de aceptación en el nuevo autómata. Realizando el proceso de inspección el AFN obtenido es el siguiente:
\begin{basedtikz}
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, above right of=q0, accepting] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \node (q3) [state, below right of=q0] {$q_3$};
        \node (q4) [state, right of=q3, accepting] {$q_4$};
        \path[thick]
        (q0) edge [bend left] node [above] {$a$} (q1)
        (q1) edge [loop above] node [above] {$a$} ()
        (q2) edge [loop above] node [above] {$b$} ()
        (q1) edge node [above] {$a,b$} (q2)
        (q0) edge node [below] {$a$} (q2)
        (q3) edge [bend left] node [above] {$b$} (q4)
        (q4) edge [bend left] node [below] {$a$} (q3)
        (q0) edge [bend left] node [above] {$b$} (q4);
    \end{tikzpicture}
\end{basedtikz}
Si bien la presentación del autómata podría ser mas pulida recomendamos dejar los estados en las posiciones originales para hacer mas evidente y sencillo el proceso de inspección.\\

\textbf{Punto 3: }Primero hallemos la $\lambda$-clausura de cada estado:
\begin{align*}
    \lambda[q_0]&=\{q_0,q_1,q_2\}\\
    \lambda[q_1]&=\{q_1\}\\
    \lambda[q_2]&=\{q_2\}\\
    \lambda[q_3]&=\{q_3\}\\ 
    \lambda[q_4]&=\{q_4\}
\end{align*}
Los estados $q_1$ y $q_2$ son de aceptación en el original, en el nuevo autómata también son de aceptación y ademas lo sera el estado $q_0$. Realizando la inspección obtenemos el siguiente AFN:  
\begin{basedtikz}
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q2) [state, right of=q0, accepting] {$q_2$};
        \node (q1) [state, above of=q2, accepting] {$q_1$};
        \node (q3) [state, above right of=q2] {$q_3$};
        \node (q4) [state, below right of=q2] {$q_4$};
        \path[thick]
        (q0) edge node [above] {$a$} (q1)
        (q0) edge [bend left=10] node [above] {$a$} (q3)
        (q1) edge [loop above] node [above] {$a$} ()
        (q2) edge [bend left=20] node [left] {$a$} (q3)
        (q3) edge [bend left=20] node [right] {$b$} (q2)
        (q2) edge [bend right=20] node [left] {$b$} (q4)
        (q4) edge [bend right=20] node [right] {$a$} (q2)
        (q0) edge [bend right] node [below] {$b$} (q4);
    \end{tikzpicture}
\end{basedtikz} 

\textbf{Punto 4: }Primero hallemos la $\lambda$-clausura de cada estado:
\begin{align*}
    \lambda[q_0]&=\{q_0,q_1\}\\
    \lambda[q_1]&=\{q_1\}\\
    \lambda[q_2]&=\{q_2,q_3\}\\
    \lambda[q_3]&=\{q_3\}\\ 
    \lambda[q_4]&=\{q_1,q_4\}
\end{align*}
El único estado de aceptación original es $q_3$ y la única $\lambda$-clausura a la que pertenece es $\lambda[q_2]$ entonces en el nuevo autómata los estados de aceptación son $q_2$ y $q_3$. Realizando el proceso de inspección obtenemos el siguiente AFN:
\pagebreak
\begin{basedtikz}
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \node (q3) [state, right of=q2, accepting] {$q_3$};
        \node (q4) [state, above of=q0] {$q_4$};
        \path[thick]
        (q0) edge [bend left] node [left] {$a$} (q4)
        (q4) edge [bend left] node [right] {$b$} (q0)
        (q0) edge node [above] {$a$} (q1)
        (q1) edge node [above] {$a$} (q2)
        (q2) edge node [above] {$a,b$} (q3)
        (q2) edge [loop above] node [above] {$b$} ()
        (q3) edge [loop above] node [above] {$a$} ()
        (q4) edge node [above] {$b$} (q1)
        (q4) edge [bend left] node [above] {$a$} (q2)
        (q4) edge [bend left] node [above] {$a$} (q3)
        (q0) edge [bend right] node [below] {$a$} (q2)
        (q0) edge [bend right=45] node [below] {$a$} (q3);
    \end{tikzpicture}
\end{basedtikz}
Observe que la importancia radica en el hecho de que de ahora en adelante si nos atascamos en la construcción de un AFD e incluso de un AFN podemos siempre construir un AFN-$\lambda$, luego convertirlo en un AFN y por ultimo convertirlo en un AFD. Si bien es un proceso largo nos garantiza un AFD que funcione.\\
Por ultimo en esta sección todas las conversiones fueron hechas por inspección, pero se pueden hacer por medio de la formula brindada en las notas. Sugerimos que revisen que las construcciones hechas son correctas por medio de la formula y como ejercicio interesante conviertan los AFN de esta sección en AFD.

$\hfill \blacklozenge$

\section{Complemento de un autómata determinista}

Previamente habíamos mencionado que a partir de un AFD con una condición podíamos construir un AFD para la negación de esa condición cambiando los estados de aceptación. En esta sección eso sera lo que haremos.\\ 

\textbf{Punto 1:} Construyamos primero un AFD tal que acepte todas las cadenas que contienen la subcadena $bc$. Para esto forzamos $bc$ como aceptación y consideramos los bucles necesarios.
\begin{basedtikz}
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge [loop above] node [above] {$a,c$} ()
        (q1) edge [loop above] node [above] {$b$} ()
        (q2) edge [loop above] node [above] {$a,b,c$} ()
        (q0) edge [bend left] node [above] {$b$} (q1)
        (q1) edge [bend left] node [below] {$a$} (q0)
        (q1) edge node [above] {$c$} (q2);
    \end{tikzpicture}
\end{basedtikz}
Ahora simplemente cambiamos los estados de aceptación, es decir $q_0$ y $q_1$ se vuelven de aceptación mientras que $q_2$ deja de serlo. De esta manera obtenemos el AFD que acepta el lenguaje deseado.
\pagebreak
\begin{basedtikz}
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial, accepting] {$q_0$};
        \node (q1) [state, right of=q0, accepting] {$q_1$};
        \node (q2) [state, right of=q1] {$q_2$};
        \path[thick]
        (q0) edge [loop above] node [above] {$a,c$} ()
        (q1) edge [loop above] node [above] {$b$} ()
        (q2) edge [loop above] node [above] {$a,b,c$} ()
        (q0) edge [bend left] node [above] {$b$} (q1)
        (q1) edge [bend left] node [below] {$a$} (q0)
        (q1) edge node [above] {$c$} (q2);
    \end{tikzpicture}
\end{basedtikz}

\textbf{Punto 2: }Primero construyamos el AFD que acepte todas las cadenas con tres unos consecutivos.
\begin{basedtikz}
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1] {$q_2$};
        \node (q3) [state, right of=q2, accepting] {$q_3$};
        \path[thick]
        (q0) edge [loop above] node [above] {$0$} ()
        (q0) edge [bend left] node [above] {$1$} (q1)
        (q1) edge [bend left] node [below] {$0$} (q0)
        (q1) edge node [above] {$1$} (q2)
        (q2) edge node [above] {$1$} (q3)
        (q2) edge [bend left=60] node [below] {$0$} (q0)
        (q3) edge [loop above] node [above] {$0,1$} ();
    \end{tikzpicture}
\end{basedtikz}
Luego el AFD que acepta el lenguaje deseado es:
\begin{basedtikz}
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial, accepting] {$q_0$};
        \node (q1) [state, right of=q0, accepting] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \node (q3) [state, right of=q2] {$q_3$};
        \path[thick]
        (q0) edge [loop above] node [above] {$0$} ()
        (q0) edge [bend left] node [above] {$1$} (q1)
        (q1) edge [bend left] node [below] {$0$} (q0)
        (q1) edge node [above] {$1$} (q2)
        (q2) edge node [above] {$1$} (q3)
        (q2) edge [bend left=60] node [below] {$0$} (q0)
        (q3) edge [loop above] node [above] {$0,1$} ();
    \end{tikzpicture}
\end{basedtikz}

\textbf{Punto 3: }Primero construyamos el AFD que acepta todas las cadenas que terminan en 01.
\begin{basedtikz}
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge [loop above] node [above] {$1$} ()
        (q1) edge [loop above] node [above] {$0$} ()
        (q1) edge [bend left] node [above] {$1$} (q2)
        (q2) edge [bend left] node [below] {$0$} (q1)
        (q0) edge node [above] {$0$} (q1)
        (q2) edge [bend left=60] node [below] {$1$} (q0);
    \end{tikzpicture}
\end{basedtikz}
Luego el AFD que acepta el lenguaje deseado es:
\begin{basedtikz}
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial, accepting] {$q_0$};
        \node (q1) [state, right of=q0, accepting] {$q_1$};
        \node (q2) [state, right of=q1] {$q_2$};
        \path[thick]
        (q0) edge [loop above] node [above] {$1$} ()
        (q1) edge [loop above] node [above] {$0$} ()
        (q1) edge [bend left] node [above] {$1$} (q2)
        (q2) edge [bend left] node [below] {$0$} (q1)
        (q0) edge node [above] {$0$} (q1)
        (q2) edge [bend left=60] node [below] {$1$} (q0);
    \end{tikzpicture}
\end{basedtikz}

\textbf{Punto 4: }Primero construyamos el AFD que acepta todas las cadenas que terminan en 22.
\begin{basedtikz}
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge [loop above] node [above] {$0,1$} ()
        (q2) edge [loop above] node [above] {$2$} ()
        (q0) edge [bend left] node [above] {$2$} (q1)
        (q1) edge [bend left] node [below] {$0,1$} (q0)
        (q1) edge node [above] {$2$} (q2)
        (q2) edge [bend left=60] node [below] {$0,1$} (q0);
    \end{tikzpicture}
\end{basedtikz}
Luego el AFD que acepta el lenguaje deseado es:
\begin{basedtikz}
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial, accepting] {$q_0$};
        \node (q1) [state, right of=q0, accepting] {$q_1$};
        \node (q2) [state, right of=q1] {$q_2$};
        \path[thick]
        (q0) edge [loop above] node [above] {$0,1$} ()
        (q2) edge [loop above] node [above] {$2$} ()
        (q0) edge [bend left] node [above] {$2$} (q1)
        (q1) edge [bend left] node [below] {$0,1$} (q0)
        (q1) edge node [above] {$2$} (q2)
        (q2) edge [bend left=60] node [below] {$0,1$} (q0);
    \end{tikzpicture}
\end{basedtikz}

Note que en los puntos 1 y 2, los estados $q_2$ y $q_3$ se volvieron limbo respectivamente y es posible quitarlos para una presentación simplificada del AFD, pero es preferible no retirarlos con el propósito de observar correctamente el proceso del complemento.

$\hfill \blacklozenge$ 

\section{Producto cartesiano de autómatas deterministas}

En esta sección observaremos otra manera de construir AFD para lenguajes que tengan dos condiciones los cuales puede que sean complicados por simple inspección, pero que con el algoritmo, se facilita muchísimo.\\

\textbf{Punto 1: }Primero considere el AFD $M_1$ que acepta $L_1$ (las cadenas de longitud impar):
\begin{basedtikz}
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0, accepting] {$q_1$};
        \path[thick]
        (q0) edge [bend left] node [above] {$a,b$} (q1)
        (q1) edge [bend left] node [below] {$a,b$} (q0);
    \end{tikzpicture}
\end{basedtikz}
Ahora construyamos el AFD $M_2$ que acepta $L_2$ (las cadenas que contienen dos $bes$ consecutivas):
\begin{basedtikz}
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q2) [state, initial] {$q_2$};
        \node (q3) [state, right of=q2] {$q_3$};
        \node (q4) [state, right of=q3, accepting] {$q_4$};
        \path[thick]
        (q2) edge [loop above] node [above] {$a$} ()
        (q2) edge [bend left] node [above] {$b$} (q3)
        (q3) edge [bend left] node [below] {$a$} (q2)
        (q3) edge node [above] {$b$} (q4)
        (q4) edge [loop above] node [above] {$a,b$} ();
    \end{tikzpicture}
\end{basedtikz}

Entonces $L=L(M_1)-L(M_2)=L_1-L_2$. El producto cartesiano $M_1\times M_2$ tiene en total 6 estados: $(q_0,q_2),(q_0,q_3),(q_0,q_4),(q_1,q_2),(q_1,q_3)$ y $(q_1,q_4)$; donde los estados de aceptación son $(q_1,q_2)$ y $(q_1,q_3)$ Luego siguiendo la función de transición definida se tiene que el AFD $M$ tal que $L(M)=L$ es:
\begin{basedtikz}
    \begin{tikzpicture}[node distance = 5cm, on grid, auto]
        \node (q02) [state, initial] {$(q_0,q_2)$};
        \node (q12) [state, right of=q02, accepting] {$(q_1,q_2)$};
        \node (q03) [state, right of=q12] {$(q_0,q_3)$};
        \node (q13) [state, below of=q02, accepting] {$(q_1,q_3)$};
        \node (q04) [state, right of=q13] {$(q_0,q_4)$};
        \node (q14) [state, right of=q04] {$(q_1,q_4)$};
        \path[thick]
        (q02) edge [bend left] node [above] {$a$} (q12)
        (q12) edge [bend left] node [below] {$a$} (q02)
        (q03) edge [bend left] node [below] {$a$} (q12)
        (q02) edge [bend right] node [left] {$b$} (q13)
        (q13) edge [bend right] node [right] {$a$} (q02)
        (q12) edge [bend left] node [above] {$b$} (q03)
        (q13) edge node [above] {$b$} (q04)
        (q03) edge node [right] {$b$} (q14)
        (q04) edge [bend left] node [above] {$a,b$} (q14)
        (q14) edge [bend left] node [below] {$a,b$} (q04);
        \end{tikzpicture}
\end{basedtikz}
Note que los estados $(q_0,q_4)$ y $(q_1,q_4)$ son estados limbo, así el autómata simplificado es el siguiente:
\begin{basedtikz}
    \begin{tikzpicture}[node distance = 5cm, on grid, auto]
        \node (q02) [state, initial] {$(q_0,q_2)$};
        \node (q12) [state, right of=q02, accepting] {$(q_1,q_2)$};
        \node (q03) [state, right of=q12] {$(q_0,q_3)$};
        \node (q13) [state, below of=q02, accepting] {$(q_1,q_3)$};
        \path[thick]
        (q02) edge [bend left] node [above] {$a$} (q12)
        (q12) edge [bend left] node [below] {$a$} (q02)
        (q03) edge [bend left] node [below] {$a$} (q12)
        (q02) edge [bend right] node [left] {$b$} (q13)
        (q13) edge [bend right] node [right] {$a$} (q02)
        (q12) edge [bend left] node [above] {$b$} (q03);
        \end{tikzpicture}
\end{basedtikz}
Observe que la solución presentada es igual a la del ejemplo correspondiente a este lenguaje, salvo la posición de los estados.\\

\textbf{Punto 2: }
\begin{itemize}[label={✎}]
    \item Considere el AFD $M_1$ que acepta $L_1$ (las cadenas de que tienen longitud par):
    \begin{basedtikz}
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial, accepting] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \path[thick]
        (q0) edge [bend left] node [above] {$0,1$} (q1)
        (q1) edge [bend left] node [below] {$0,1$} (q0);
    \end{tikzpicture}
\end{basedtikz}
Ahora considere el AFD $M_2$ que acepta $L_2$ (las cadenas que terminan en $10$):
\begin{basedtikz}
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q2) [state, initial] {$q_2$};
        \node (q3) [state, right of=q2] {$q_3$};
        \node (q4) [state, right of=q3, accepting] {$q_4$};
        \path[thick]
        (q2) edge [loop above] node [above] {$0$} ()
        (q2) edge node [above] {$1$} (q3)
        (q3) edge [loop above] node [above] {$1$} ()
        (q3) edge [bend left] node [above] {$0$} (q4)
        (q4) edge [bend left=60] node [below] {$0$} (q2)
        (q4) edge [bend left] node [below] {$1$} (q3);   
    \end{tikzpicture}
\end{basedtikz}
Entonces $L=L(M_1)\cup L(M_2)=L_1\cup L_2$. El producto cartesiano $M_1\times M_2$ tiene en total 6 estados: $(q_0,q_2),(q_0,q_3),(q_0,q_4),(q_1,q_2),(q_1,q_3)$ y $(q_1,q_4)$; donde los estados de aceptación son $(q_0,q_2),(q_0,q_3),(q_0,q_4)$ y $(q_1,q_4)$. Luego siguiendo la función de transición definida se tiene que el AFD $M$ tal que $L(M)=L$ es:
\begin{basedtikz}
    \begin{tikzpicture}[node distance = 5cm, on grid, auto]
        \node (q02) [state, initial, accepting] {$(q_0,q_2)$};
        \node (q14) [state, above right of=q02, accepting] {$(q_1,q_4)$};
        \node (q12) [state, above left of=q14] {$(q_1,q_2)$};
        \node (q03) [state, right of=q14, accepting] {$(q_0,q_3)$};
        \node (q13) [state, below right of=q03] {$(q_1,q_3)$};
        \node (q04) [state, above right of=q03, accepting] {$(q_0,q_4)$};
        \path [thick]
        (q02) edge [bend left] node [left] {$0$} (q12)
        (q12) edge [bend left] node [right] {$0$} (q02)
        (q13) edge [bend left] node [left] {$0$} (q04)
        (q04) edge [bend left] node [right] {$1$} (q13)
        (q14) edge [bend left] node [above] {$1$} (q03)
        (q03) edge [bend left] node [below] {$0$} (q14)
        (q04) edge [bend right=15] node [above] {$0$} (q12)
        (q12) edge [bend left=25] node [above] {$1$} (q03)
        (q14) edge node [above] {$0$} (q02)
        (q03) edge node [above] {$1$} (q13)
        (q02) edge  node [below] {$1$} (q13)
        (q13) edge [bend left] node [below] {$1$} (q03) ;
        \end{tikzpicture}
\end{basedtikz}
\item Considere el AFD $M_1$ que acepta $L_1$ (las cadenas de que tienen longitud impar):
    \begin{basedtikz}
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0, accepting] {$q_1$};
        \path[thick]
        (q0) edge [bend left] node [above] {$0,1$} (q1)
        (q1) edge [bend left] node [below] {$0,1$} (q0);
    \end{tikzpicture}
\end{basedtikz}
Ahora considere el AFD $M_2$ que acepta $L_2$ (las cadenas que terminan en $01$):
\begin{basedtikz}
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q2) [state, initial] {$q_2$};
        \node (q3) [state, right of=q2] {$q_3$};
        \node (q4) [state, right of=q3, accepting] {$q_4$};
        \path[thick]
        (q2) edge [loop above] node [above] {$1$} ()
        (q2) edge node [above] {$0$} (q3)
        (q3) edge [loop above] node [above] {$0$} ()
        (q3) edge [bend left] node [above] {$1$} (q4)
        (q4) edge [bend left=60] node [below] {$1$} (q2)
        (q4) edge [bend left] node [below] {$0$} (q3);   
    \end{tikzpicture}
\end{basedtikz}
Entonces $L=L(M_1)\cap L(M_2)=L_1\cap L_2$. El producto cartesiano $M_1\times M_2$ tiene en total 6 estados: $(q_0,q_2),(q_0,q_3),(q_0,q_4),(q_1,q_2),(q_1,q_3)$ y $(q_1,q_4)$; donde el único estado de aceptación es $(q_1,q_4)$. Luego siguiendo la función de transición definida se tiene que el AFD $M$ tal que $L(M)=L$ es:
\begin{basedtikz}
    \begin{tikzpicture}[node distance = 5cm, on grid, auto]
        \node (q02) [state, initial] {$(q_0,q_2)$};
        \node (q14) [state, above right of=q02, accepting] {$(q_1,q_4)$};
        \node (q12) [state, above left of=q14] {$(q_1,q_2)$};
        \node (q03) [state, right of=q14] {$(q_0,q_3)$};
        \node (q13) [state, below right of=q03] {$(q_1,q_3)$};
        \node (q04) [state, above right of=q03] {$(q_0,q_4)$};
        \path [thick]
        (q02) edge [bend left] node [left] {$1$} (q12)
        (q12) edge [bend left] node [right] {$1$} (q02)
        (q13) edge [bend left] node [left] {$1$} (q04)
        (q04) edge [bend left] node [right] {$0$} (q13)
        (q14) edge [bend left] node [above] {$0$} (q03)
        (q03) edge [bend left] node [below] {$1$} (q14)
        (q04) edge [bend right=15] node [above] {$1$} (q12)
        (q12) edge [bend left=25] node [above] {$0$} (q03)
        (q14) edge node [above] {$1$} (q02)
        (q03) edge node [above] {$0$} (q13)
        (q02) edge  node [below] {$0$} (q13)
        (q13) edge [bend left] node [below] {$0$} (q03) ;
        \end{tikzpicture}
\end{basedtikz}
\item Considere el AFD $M_1$ que acepta $L_1$ (las cadenas de que tienen longitud impar):
    \begin{basedtikz}
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0, accepting] {$q_1$};
        \path[thick]
        (q0) edge [bend left] node [above] {$0,1$} (q1)
        (q1) edge [bend left] node [below] {$0,1$} (q0);
    \end{tikzpicture}
\end{basedtikz}
Ahora considere el AFD $M_2$ que acepta $L_2$ (las cadenas que no terminan en $11$):
\begin{basedtikz}
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q2) [state, initial, accepting] {$q_2$};
        \node (q3) [state, right of=q2, accepting] {$q_3$};
        \node (q4) [state, right of=q3] {$q_4$};
        \path[thick]
        (q2) edge [loop above] node [above] {$0$} ()
        (q3) edge node [above] {$1$} (q4)
        (q4) edge [loop above] node [above] {$1$} ()
        (q2) edge [bend left] node [above] {$1$} (q3)
        (q4) edge [bend left=60] node [below] {$0$} (q2)
        (q3) edge [bend left] node [below] {$0$} (q2);   
    \end{tikzpicture}
\end{basedtikz}
Entonces $L=L(M_1)\cap L(M_2)=L_1\cap L_2$. El producto cartesiano $M_1\times M_2$ tiene en total 6 estados: $(q_0,q_2),(q_0,q_3),(q_0,q_4),(q_1,q_2),(q_1,q_3)$ y $(q_1,q_4)$; donde los estados de aceptación son $(q_1,q_2)$ y $(q_1,q_3)$. Luego siguiendo la función de transición definida se tiene que el AFD $M$ tal que $L(M)=L$ es:
\begin{basedtikz}
    \begin{tikzpicture}[node distance = 4cm, on grid, auto]
        \node (q02) [state, initial] {$(q_0,q_2)$};
        \node (q12) [state, right of=q02, accepting] {$(q_1,q_2)$};
        \node (q03) [state, right of=q12] {$(q_0,q_3)$};
        \node (q13) [state, below of=q02, accepting] {$(q_1,q_3)$};
        \node (q14) [state, right of=q03] {$(q_1,q_4)$};
        \node (q04) [state, below of=q14] {$(q_0,q_4)$};
        \path[thick]
        (q02) edge [bend left] node [above] {$0$} (q12)
        (q12) edge [bend left] node [below] {$0$} (q02)
        (q03) edge [bend left] node [below] {$0$} (q12)
        (q02) edge [bend right] node [left] {$1$} (q13)
        (q13) edge [bend right] node [right] {$0$} (q02)
        (q12) edge [bend left] node [above] {$1$} (q03)
        (q13) edge node [below] {$1$} (q04)
        (q03) edge node [above] {$1$} (q14)
        (q14) edge [bend right=50] node [above] {$0$} (q02)
        (q04) edge [bend left=15] node [below] {$0$} (q12)
        (q04) edge [bend left] node [left] {$1$} (q14)
        (q14) edge [bend left] node [right] {$1$} (q04);
        \end{tikzpicture}
\end{basedtikz}
\item Considere el AFD $M_1$ que acepta $L_1$ (las cadenas de que tienen un numero par de ceros):
    \begin{basedtikz}
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial, accepting] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \path[thick]
        (q0) edge [bend left] node [above] {$0$} (q1)
        (q0) edge [loop above] node [above] {$1$} ()
        (q1) edge [loop above] node [above] {$1$} ()
        (q1) edge [bend left] node [below] {$0$} (q0);
    \end{tikzpicture}
\end{basedtikz}
Ahora considere el AFD $M_2$ que acepta $L_2$ (las cadenas que no tienen dos ceros consecutivos):
\begin{basedtikz}
    \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q2) [state, initial, accepting] {$q_2$};
        \node (q3) [state, right of=q2, accepting] {$q_3$};
        \node (q4) [state, right of=q3] {$q_4$};
        \path[thick]
        (q2) edge [loop above] node [above] {$1$} ()
        (q2) edge [bend left] node [above] {$0$} (q3)
        (q3) edge [bend left] node [below] {$1$} (q2)
        (q3) edge node [above] {$0$} (q4)
        (q4) edge [loop above] node [above] {$0,1$} ();
    \end{tikzpicture}
\end{basedtikz}
Entonces $L=L(M_1)\cup L(M_2)=L_1\cup L_2$. El producto cartesiano $M_1\times M_2$ tiene en total 6 estados: $(q_0,q_2),(q_0,q_3),(q_0,q_4),(q_1,q_2),(q_1,q_3)$ y $(q_1,q_4)$; donde los estados de aceptación son $(q_0,q_2),(q_0,q_3),(q_0,q_4),(q_1,q_2)$ y $(q_1,q_3)$. Luego siguiendo la función de transición definida se tiene que el AFD $M$ tal que $L(M)=L$ es:
\begin{basedtikz}
    \begin{tikzpicture}[node distance = 5cm, on grid, auto]
        \node (q02) [state, initial, accepting] {$(q_0,q_2)$};
        \node (q13) [state, right of=q02, accepting] {$(q_1,q_3)$};
        \node (q04) [state, right of=q13, accepting] {$(q_0,q_4)$};
        \node (q03) [state, below of=q02, accepting] {$(q_0,q_3)$};
        \node (q12) [state, right of=q03, accepting] {$(q_1,q_2)$};
        \node (q14) [state, right of=q12] {$(q_1,q_4)$};
        \path[thick]
        (q02) edge [loop above] node [above] {$1$} ()
        (q04) edge [loop above] node [above] {$1$} ()
        (q12) edge [loop right] node [right] {$1$} ()
        (q14) edge [loop right] node [right] {$1$} ()
        (q02) edge node [above] {$0$} (q13)
        (q13) edge node [above] {$0$} (q04)
        (q13) edge node [right] {$1$} (q12)
        (q12) edge node [below] {$0$} (q03)
        (q03) edge node [left] {$1$} (q02)
        (q03) edge [bend right] node [below] {$0$} (q14)
        (q04) edge [bend left] node [right] {$0$} (q14)
        (q14) edge [bend left] node [left] {$0$} (q04);
        \end{tikzpicture}
\end{basedtikz}
\end{itemize}

\textbf{Punto 3: }
\begin{itemize}[label={✎}]
    \item 
\end{itemize}

\textbf{Punto 4: } 

