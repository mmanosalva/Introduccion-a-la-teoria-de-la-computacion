%!TEX root = main.tex
En este capítulo comenzamos la segunda parte de las notas de clase, en estas secciones resaltamos que no hay una única solución a los ejercicios y que algunas de las soluciones pueden llegar a ser redundantes, sin embargo son funcionales y esto es lo que más nos interesa.

\section{Expresiones regulares}

\textbf{Punto 1:} \begin{itemize}
    \item [✎] La solución más evidente es la siguiente: $b(a\cup b)^*a$, con $(a\cup b)^*$ consideramos todas las cadenas y lo que hacemos es forzar que las cadenas comiencen con $b$ y terminen en $a$ concatenando.

    \item[✎] Sabemos que para generar todas las cadenas de longitud par usamos $(aa\cup bb\cup ab\cup ba)^*=((a\cup b)(a\cup b))^*$, luego para generar las impares debemos considerar 4 casos y unirlos:

    $$a((a\cup b)(a\cup b))^*\cup b((a\cup b)(a\cup b))^* \cup ((a\cup b)(a\cup b))^*a \cup ((a\cup b)(a\cup b))^*b$$

    Esto convierte las cadenas pares en impares siempre y considera los casos en que comience por $a$ o por $b$ o termine por $a$ o $b$ (se puede llegar a una solución mejor quizá).

    \item[✎] Sabemos que $(b^*ab^*ab^*)^*$ genera todas las cadenas con un número par (mayor que 0) de $aes$, luego usando este hecho construimos:

    $$a(b^*ab^*ab^*)^*\cup (b^*ab^*ab^*)^*a$$

    y acabamos.

    \item[✎] Sabemos generar las cadenas de $a$ y $b$ que contienen un número par de $a$ o $b$, la solución está propuesta en las notas de clase, luego cambiamos un poco la expresión de esta forma:

    $$a^*(a^*ba^*ba^*ba^*)^*$$

    La expresión $a^*(ba^*ba^*b)^*a^*$ también es una solución.

    \item[✎] Para este caso las cadenas pueden comenzar por $a$, $ab$, $b^2$, $a^2$, luego obtenemos la expresión:

    $$(a\cup ab \cup b^2 \cup a^2)(a \cup b)^*a $$

    Ya que tampoco pueden acabar en $b$, ahora no falta notas que por agregar esta $a$ al final y la expresión $(a\cup ab \cup b^2 \cup a^2)$ es imposible obtener la cadena vacía y la cadena $a$, pues las añadimos y nos queda finalmente:

     $$(a\cup ab \cup b^2 \cup a^2)(a \cup b)^*a \cup a \cup \lambda$$

     \item[✎] Para la expresión regular en este caso notemos que toda cadena tiene bloques de la forma $ba$ donde estos van intercalados con un numero de $a$ arbitrarias así obtenemos la expresión:

     $$(a\cup ba)^*$$

     Observe que las $b$ están restringidas ya que para $b\geq 2$ las cadenas de este estilo no pueden tener una $a$ luego de la cantidad arbitraria de $bes$, pero esta expresión no contempla las cadenas del estilo $bb\dots b$, para esto basta concatenar estas cadenas al final, obteniendo finalmente la expresión:

     $$(a\cup ba)^*b^*$$

\end{itemize}

\textbf{Punto 2:} \begin{itemize}
    \item[✎] Al igual que en el primer ítem del punto anterior, lo mas natural es forzar que la cadena empiece en con $2$ y termine en $1$, concatenando respectivamente obtenemos la expresión $2(0\cup1\cup2)^*1$.

    \item[✎] Similar a la construcción anterior podemos forzar a que las cadenas no empiecen con $2$ ni terminen con $1$ concatenando $(0\cup1)$ y $(0\cup2)$ respectivamente. De esta forma obtenemos la expresión:
    
    $$(0\cup1)(0\cup1\cup2)^*(0\cup2)$$

    Note que en el lenguaje propuesto las cadenas $\lambda$ y $0$ también cumplen la condición, pero es imposible generarlas por medio de la expresión dada. Afortunadamente arreglar esto es sencillo ya que podemos agregarlas por medio de uniones, obteniendo así:

    $$(0\cup1)(0\cup1\cup2)^*(0\cup2)\cup\lambda\cup0$$

    \item[✎] Nuevamente la forma mas natural de construir la expresión que represente al lenguaje es forzando que aparezcan solo $2$ ceros, tenga en cuenta que los ceros pueden estar en cualquier posición y por tanto la expresión es la siguiente $(1\cup2)^*0(1\cup2)^*0(1\cup2)^*$.

    \item[✎] Ya sabemos como generar los bloques de dos elementos de un lenguaje, para este caso $(0\cup1\cup2)(0\cup1\cup2)=(0\cup1\cup2)^2$, luego de esto basta concatenar estos bloques de todas la formas posibles, obteniendo así la expresión:

    $$\left((0\cup1\cup2)^2\right)^*$$

    \item[✎] Usando la expresión del ítem anterior, si concatenamos al final $0$,$1$ o $2$ obtenemos las cadenas de longitud impar, es decir:
    
    $$\left((0\cup1\cup2)^2\right)^*(0\cup1\cup2)$$

    \item[✎] Como no pueden aparecer dos unos consecutivos, las cadenas contienen bloques de la forma $(0\cup2)1(0\cup2)$, y junto a ellas cantidades arbitrarias de ceros y dos alternados:

    $$(0\cup2\cup(0\cup2)1(0\cup2))^*$$

    Observe que si bien esta expresión nos da múltiples cadenas aun hay varias que no genera. Por ejemplo no genera cadenas que empiecen o terminen en $1$. Esto podemos agregarlo concatenado $1\cup\lambda$ al inicio y final de la expresión:

    $$(1\cup\lambda)(0\cup2\cup(0\cup2)1(0\cup2))^+(1\cup\lambda)$$

    La cadena $\lambda$ es de vital importancia en la expresión ya que esta nos permite concatenar sin perder las cadenas que ya teníamos previamente. Además note que en la expresión cambiamos la $*$ por un $+$, esto se debe a que si no realizamos este cambio generaríamos la cadena $11$ y esta no cumple los criterios del lenguaje, por ultimo las cadenas $\lambda$ y $1$ cumplen las condiciones, mas no pueden ser generadas por lo que solo queda agregarlas y así obtener la expresión final:

    $$(1\cup\lambda)(0\cup2\cup(0\cup2)1(0\cup2))^+(1\cup\lambda)\cup\lambda\cup1$$
\end{itemize}

\textbf{Punto 3:} \begin{itemize}
    \item[✎] Para que una cadena tenga al menos un $0$ y un $1$ debe ser mínimo un bloque $01$ o un bloque $10$, luego simplemente fijamos esas dos posibilidades para que la solución sea  $(0\cup1)^*(01\cup10)(0\cup1)^*$.

    \item[✎]La condición nos indica que en las cadenas solo pueden haber uno o dos ceros consecutivos, es decir las forman bloque de la forma $01$ o $001$, luego podemos generar la expresión:

    $$(1\cup01\cup001)^*$$

    Note que esta  no contempla cadenas que terminen en uno o dos ceros, pero esto lo podemos arreglar fácilmente concatenando lo necesario:

    $$(1\cup01\cup001)^*(\lambda\cup0\cup00)$$

    \item[✎]Para esta solución simplemente consideremos las cadenas de longitud $4$ es decir las que son generadas por $(0\cup1)^4$, luego como estas son las mínimas cadenas que acepta el lenguaje solo queda hacer que aparezcan las demás posibilidades así $(0\cup1)^4(0\cup1)^*$.

    \item[✎]Note que al forzar que el quinto símbolo de izquierda a derecha sea un $1$ en todas las cadenas básicamente podemos rehusar la solución anterior forzando la condición de esta forma $(0\cup1)^41(0\cup1)^*$.

    \item[✎]Si la cadena no puede terminar en $01$ forzosamente tiene que terminar en $00,10$ o $11$, forzando estas obtenemos:

    $$(0\cup1)^*(00\cup10\cup11)$$

    Observe que esta expresión solo genera cadenas de longitud $\geq2$ pero las cadenas $\lambda,0$ y $1$ cumplen la condición, entonces:

    $$(0\cup1)^*(00\cup10\cup11)\cup\lambda\cup0\cup1$$

    De esta forma terminamos.

    \item[✎]Como son cadenas de longitud par, pueden ser formadas por bloques de la forma $01$ o de la forma $10$ luego la solución luce de esta forma $(01)^+\cup(10)^+$. Note que usamos $+$ ya que la cadena $\lambda$ no es aceptada en este lenguaje.

    \item[✎]Como en el ejercicio anterior ya construimos las cadenas pares, solo nos queda construir todas las impares. Esto lo logramos por medio de concatenar un elemento mas a las expresiones que ya tenemos. La solución luce de la siguiente forma:

    $$(1\cup\lambda)(01)^+\cup(0\cup\lambda)(10)^+$$

    \item[✎]Note que si no pueden haber dos ceros seguidos ni dos unos seguidos, los ceros y los unos deben de ir alternados forzosamente, es decir que la solución es la misma que la del ejercicio previo, exceptuando un detalle:

     $$(1\cup\lambda)(01)^*\cup(0\cup\lambda)(10)^*$$

     Observe que cambiamos el $+$ por una $*$, esto se debe a que las cadenas $\lambda,0$ y $1$ si son validas en este lenguaje.

     \item[✎]Para generar cadenas cuya longitud es un múltiplo de 3, necesitamos todos los bloques de longitud $3$ y posteriormente los concatenamos de todas las formas posibles, es decir tenemos la expresión $\left((0\cup1)^3\right)^*$. Recuerde que $0$ es múltiplo de $3$ por eso usamos el $*$ para asegurar la cadena $\lambda$.

      \item[✎]Esta expresión sigue un análisis muy similar al de las cadenas donde no podían haber tres ceros consecutivos, de esta forma solo falta agregar los bloques $0001$ y $000$ respectivamente a la expresión que habíamos obtenido:

      $$(1\cup01\cup001\cup0001)^*(\lambda\cup0\cup00\cup000)$$

      \item[✎]Observe que la cadena tiene que empezar por $1$ o $01$ y de forma similar tiene que acabar en $0$ o en $01$. Forzando estos símbolos obtenemos:

      $$(1\cup01)(0\cup1)^*(0\cup01)$$

      Ahora como usualmente ha ocurrido a lo largo de esta sección, al forzar cadenas en la expresión, no generamos cadenas que si son aceptadas dentro del lenguaje, pero basta con simplemente agregarlas:

      $$(1\cup01)(0\cup1)^*(0\cup01)\cup\lambda\cup0\cup1\cup01$$

      \item[✎]Para que no contengan la subcadena $101$ note que se debe forzar que en todas las expresiones aparezcan al menos dos ceros entre dos unos, las cadenas de este estilo se consiguen por medio de la expresión:

      $$(1\cup00^+)^*$$

      Uno podría verse tentado en pensar que esta es la solución, pero observe que esta expresión no contempla cadenas que empiecen por $01$ y que son totalmente validas, además tampoco contempla cadenas que terminen en un solo cero:

      $$(01\cup\lambda)(1\cup00^+)^*(0\cup\lambda)$$

      Luego de este arreglo si podemos asegurar que están todas las cadenas.
  
\end{itemize}

\hfill $\blacklozenge$

\section{Diseño de autómatas}


Al igual que en la sección anterior las soluciones de este capitulo no son únicas y puede que algunas sean redundantes, además otra aclaración de vital importancia es que todos los autómatas presentados no muestran sus estados limbo, es decir presentaremos AFD simplificados.\\

\textbf{Punto 1:}
\begin{itemize}[label={✎}]
    \item Como la cadena mínima es $\lambda$ entonces el estado inicial tiene que ser de aceptación, luego como también se aceptan $aes$ arbitrarias estas pueden ser aceptadas por medio de un bucle. Apenas aparezca una $b$ el autómata cambiara de estado pero ese seria también de aceptación, incluyendo un bucle para las $bes$ arbitrarias:\\
    \begin{center}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0, accepting] {$q_1$};
            \path [thick]
            (q0) edge [loop above] node {$a$} ()
            (q0) edge node [above] {$b$} (q1)
            (q1) edge [loop above] node {$b$} ();
        \end{tikzpicture}
    \end{center}

    \item Nuevamente el estado inicial es de aceptación ya que $\lambda$ pertenece a el lenguaje, luego basta con tomar dos caminos para el caso donde sean cadenas de $aes$ y el de cadenas de $bes$:
    \begin{center}
        \begin{tikzpicture}[node distance = 2cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q1) [state, above right of=q0, accepting] {$q_1$};
            \node (q2) [state, below right of=q0, accepting] {$q_2$};
            \path[thick]
            (q0) edge [bend left] node [above left] {$a$} (q1)
            (q0) edge [bend right] node [below left] {$b$} (q2)
            (q1) edge [loop above] node {$a$} ()
            (q2) edge [loop below] node {$b$} ();
        \end{tikzpicture}    
    \end{center}

    \item Note que todas las cadenas de este lenguaje son de la forma $ab\dots ab$, es decir siempre son bloques $ab$ y todas las cadenas empiezan en $a$ y terminan en $b$:
    \begin{center}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$b$} (q0);
        \end{tikzpicture}
    \end{center}

    \item Bastante similar a la anterior excepto que la cadena mínima aceptada es $ab$ debido al $+$, así que forzamos esa cadena:
    \begin{center}
        \begin{tikzpicture} [node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, accepting, right of=q1] {$q_2$};
            \path[thick]
            (q0) edge node [above] {$a$} (q1)
            (q1) edge [bend left] node [above] {$b$} (q2)
            (q2) edge [bend left] node [below] {$a$} (q1);
        \end{tikzpicture}     
    \end{center}

    \item Note que debido a la expresión se forman dos caminos, uno son las cadenas que empiezan por $a$ y luego tienen una cantidad de $bes$ arbitrarias. El otro son aquellas que comienzan por un numero de $bes$ arbitrarias pero están forzadas a terminar en $a$ para ser aceptadas:
    \begin{center}
        \begin{tikzpicture} [node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, below right of=q0, accepting] {$q_1$};
            \node (q2) [state, above right of=q0] {$q_2$};
            \node (q3) [state,  below right of=q2, accepting] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above left] {$b$} (q2)
            (q0) edge [bend right] node [below left] {$a$} (q1)
            (q1) edge [loop below] node [below] {$b$} ()
            (q2) edge [loop above] node [above] {$b$} ()
            (q2) edge [bend left] node [above right] {$a$} (q3);
        \end{tikzpicture}
    \end{center}

    \item Observe que las cadena mínima de este lenguaje tiene una sola $a$ así que el estado inicial no es de aceptación, luego note que en ambos casos de la $*$ el elemento es una $a$, por lo que forzamos dos $aes$ y posteriormente realizamos respectivamente el bucle de $aes$ y de $abes$: 
    \begin{center}
        \begin{tikzpicture} [node distance = 2.5cm, on grid, auto]
                \node (q0) [state, initial] {$q_0$};
                \node (q1) [state, right of=q0, accepting] {$q_1$};
                \node (q2) [state, right of=q1, accepting] {$q_2$};
                \path[thick]
                (q0) edge node [above] {$a$} (q1)
                (q1) edge [bend left] node [above] {$a$} (q2)
                (q2) edge [loop above] node [above] {$a$} ()
                (q2) edge [bend left] node [below] {$b$} (q1);
        \end{tikzpicture}
    \end{center}
    
    \item Observe que la cadena mínima es $aa$ entonces debemos forzar ese camino. Ahora note que en ese camino podemos generar el bucle para $a^+$. Note que hay dos posibilidades para las $bes$, o inicia la cadena con solo una $a$ y luego tiene una cantidad arbitraria de $bes$ o empieza con $aes$ arbitrarias y luego tiene $bes$ arbitrarias, pero note que siempre que aparece al menos una $b$ la cadena siempre acaba en $a$:

    \begin{center}
        \begin{tikzpicture} [node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, accepting, below right of=q1] {$q_2$};
            \node (q3) [state, above right of=q1] {$q_3$};
            \node (q4) [state, accepting, below right of=q3] {$q_4$};
            \path[thick]
            (q0) edge node [above] {$a$} (q1)
            (q1) edge [bend left] node [above] {$b$} (q3)
            (q1) edge [bend right] node [below] {$a$} (q2)
            (q2) edge [loop below] node [below] {$a$} ()
            (q2) edge node [right] {$b$} (q3)
            (q3) edge [loop above] node [above] {$b$} ()
            (q3) edge [bend left] node [above] {$a$} (q4);
        \end{tikzpicture}
    \end{center}

    \item Primero notemos que las cadenas mínimas son $a$ y $b$, así que debemos forzar dos caminos que las acepten. Ahora observe que si sale una $a$ existen dos posibilidades, es seguida inmediatamente de una $b$ o salen $aes$ arbitrarias y luego si una $b$. Note que este análisis también es valido respectivamente con $b$:

        \begin{center}
            \begin{tikzpicture} [node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, above right of=q0, accepting] {$q_1$};
            \node (q5) [state, below right of=q1, accepting] {$q_5$};
            \node (q2) [state, above right of=q5] {$q_2$};
            \node (q3) [state, below right of=q0, accepting] {$q_3$};
            \node (q4) [state, below right of=q5] {$q_4$};
            
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q0) edge [bend right] node [below] {$b$} (q3)
            (q1) edge node [above] {$a$} (q2)
            (q3) edge node [below] {$b$} (q4)
            (q2) edge [loop above] node [above] {$a$} ()
            (q4) edge [loop below] node [below] {$b$} ()
            (q2) edge node [below] {$b$} (q5)
            (q4) edge node [above] {$a$} (q5)
            (q1) edge node [below] {$b$} (q5)
            (q3) edge node [above] {$a$} (q5);     
            \end{tikzpicture}
        \end{center}

        \item Observe que nuestras dos cadenas mínimas de aceptación son $ab$ y $ba$ así que forzamos esos dos caminos. Posteriormente para hacer que aparezcan las $bes$ arbitrarias podemos agregar un bucle en el camino donde generamos $ba$. Si lo dejáramos hasta ahí nos faltarían las cadenas de la forma $b^*ab$ pero esto se arregla fácilmente conectando el camino de $ba$ al de $ab$ colocando una $b$ entre estados de aceptación:
        \begin{center}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
                \node (q0) [state, initial] {$q_0$};
                \node (q1) [state, above right of=q0] {$q_1$};
                \node (q2) [state, right of=q1, accepting] {$q_2$};
                \node (q3) [state, below right of=q0] {$q_3$};
                \node (q4) [state, right of=q3, accepting] {$q_4$};
                \path[thick]
                (q0) edge [bend left] node [above] {$a$} (q1)
                (q1) edge node [above] {$b$} (q2)
                (q0) edge [bend right] node [below] {$b$} (q3)
                (q3) edge [loop below] node [below] {$b$} ()
                (q3) edge node [below] {$a$} (q4)
                (q4) edge node [right] {$b$} (q2);
            \end{tikzpicture}
        \end{center}

        \item Note que el lenguaje es muy parecido a excepción de que las cadenas forzosamente acaban en por lo menos una $a$, pero lo que podemos hacer es usar el autómata construido previamente y aquellos estados de aceptación forzamos que salga una $a$ hacia un nuevo estado de aceptación que generara la concatenación de $a^+$:

        \begin{center}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
                \node (q0) [state, initial] {$q_0$};
                \node (q1) [state, above right of=q0] {$q_1$};
                \node (q2) [state, right of=q1] {$q_2$};
                \node (q3) [state, below right of=q0] {$q_3$};
                \node (q4) [state, right of=q3] {$q_4$};
                \node (q5) [state, above right of=q4, accepting] {$q_5$};
                \path[thick]
                (q0) edge [bend left] node [above] {$a$} (q1)
                (q1) edge node [above] {$b$} (q2)
                (q0) edge [bend right] node [below] {$b$} (q3)
                (q3) edge [loop below] node [below] {$b$} ()
                (q3) edge node [below] {$a$} (q4)
                (q4) edge node [right] {$b$} (q2)
                (q2) edge [bend left] node [above] {$a$} (q5)
                (q4) edge [bend right] node [below] {$a$} (q5)
                (q5) edge [loop right] node [right] {$a$} ();
            \end{tikzpicture}
        \end{center} 
    \end{itemize}
\textbf{Punto 2:}
\begin{itemize}[label={✎}]
    \item Recordemos que si por ejemplo queremos construir un autómata que acepte el lenguaje de las cadenas que tienen una cantidad par de $aes$ hacemos la siguiente construcción:
    \begin{center}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0);
        \end{tikzpicture}
    \end{center}
Note como la construcción para cantidad par de $bes$ es la misma entonces basta simplemente con agregar un camino para estas en el autómata ya diseñado hacia un nuevo estado:
\begin{center}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, below of=q0] {$q_2$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge [bend left] node [right] {$b$} (q2)
            (q2) edge [bend left] node [left] {$b$} (q0);
        \end{tikzpicture}
    \end{center}

Observe que este autómata no acepta por ejemplo las cadenas $abab$ o $abba$. Aquí entra en juego la recomendación de usar 4 estados para la construcción y de esta forma podremos crear estos caminos para aceptar aquellas cadenas que antes no y que si son generadas por el lenguaje:

\begin{center}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, below of=q0] {$q_2$};
            \node (q3) [state, below of=q1] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge [bend left] node [right] {$b$} (q2)
            (q2) edge [bend left] node [left] {$b$} (q0)
            (q2) edge [bend left] node [above] {$a$} (q3)
            (q3) edge [bend left] node [below] {$a$} (q2)
            (q1) edge [bend left] node [right] {$b$} (q3)
            (q3) edge [bend left] node [left] {$b$} (q1);
        \end{tikzpicture}
    \end{center}

    Algo importante a destacar aquí es que el único estado de aceptación es $q_0$ ya que en los demás siempre hay cantidad impar de $aes$ o $bes$. Esto es relevante ya que es la esencia del siguiente ejercicio.

    \item Observe que para este ejercicio tenemos ocho posibilidades en total, bueno para ser exactos simplemente tenemos que hacer $7$ ya que en el anterior ya cubrimos el caso par de $aes$ y par de $bes$. La forma en que determinaremos que estados se vuelven de aceptación es considerando cadenas básicas que cumplen las condiciones y en que estado terminan.\\

    \textbf{Caso 1: }Impar de $aes$ o impar de $bes$. Note que en el autómata original $q_1,q_2$ y $q_3$ no son de aceptación ya que en todos $aes$ o $bes$ son impares, luego en este caso estos tres se vuelven de aceptación mientras que $q_0$ ya no lo es.
    \begin{center}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial] {$q_0$};
            \node (q1) [state, right of=q0, accepting] {$q_1$};
            \node (q2) [state, below of=q0, accepting] {$q_2$};
            \node (q3) [state, below of=q1, accepting] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge [bend left] node [right] {$b$} (q2)
            (q2) edge [bend left] node [left] {$b$} (q0)
            (q2) edge [bend left] node [above] {$a$} (q3)
            (q3) edge [bend left] node [below] {$a$} (q2)
            (q1) edge [bend left] node [right] {$b$} (q3)
            (q3) edge [bend left] node [left] {$b$} (q1);
        \end{tikzpicture}
    \end{center}

    \textbf{Caso 2: }Par de $aes$ o par de $bes$. Observe que el estado $q_0$ lo mantenemos como aceptación, luego note que la cadena $abb$ es aceptada por la condición y si seguimos este camino en el autómata $q_1$ debe ser de aceptación. De la misma manera $q_2$ tiene que ser de aceptación ya que la cadena $baa$ también es aceptada.
    \begin{center}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0, accepting] {$q_1$};
            \node (q2) [state, below of=q0, accepting] {$q_2$};
            \node (q3) [state, below of=q1] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge [bend left] node [right] {$b$} (q2)
            (q2) edge [bend left] node [left] {$b$} (q0)
            (q2) edge [bend left] node [above] {$a$} (q3)
            (q3) edge [bend left] node [below] {$a$} (q2)
            (q1) edge [bend left] node [right] {$b$} (q3)
            (q3) edge [bend left] node [left] {$b$} (q1);
        \end{tikzpicture}
    \end{center}

    \textbf{Caso 3: }Impar de $aes$ e impar de $bes$. Note que en la construcción anterior el estado $q_3$ no es de aceptación ya que es el único lugar donde $aes$ y $bes$ son impares, entonces para este caso ese va a ser nuestro único estado de aceptación.
    \begin{center}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, below of=q0] {$q_2$};
            \node (q3) [state, below of=q1, accepting] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge [bend left] node [right] {$b$} (q2)
            (q2) edge [bend left] node [left] {$b$} (q0)
            (q2) edge [bend left] node [above] {$a$} (q3)
            (q3) edge [bend left] node [below] {$a$} (q2)
            (q1) edge [bend left] node [right] {$b$} (q3)
            (q3) edge [bend left] node [left] {$b$} (q1);
        \end{tikzpicture}
    \end{center}

    \textbf{Caso 4: }Par de $aes$ e impar de $bes$. Observe que una cadena aceptada por estas condiciones es la cadena $baa$ y esta es aceptada en $q_2$ luego este tiene que ser de aceptación. Ahora note que ninguno de los demás es de aceptación ya que $q_0,q_1$ aceptan cadenas con un numero par de $bes$ y $q_3$ acepta cadenas con un numero impar de $aes$.
\begin{center}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, below of=q0, accepting] {$q_2$};
            \node (q3) [state, below of=q1] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge [bend left] node [right] {$b$} (q2)
            (q2) edge [bend left] node [left] {$b$} (q0)
            (q2) edge [bend left] node [above] {$a$} (q3)
            (q3) edge [bend left] node [below] {$a$} (q2)
            (q1) edge [bend left] node [right] {$b$} (q3)
            (q3) edge [bend left] node [left] {$b$} (q1);
        \end{tikzpicture}
    \end{center}
    \textbf{Caso 5: }Impar de $aes$ o par de $bes$. Por las $bes$ pares $q_0$ es de aceptación. Por el impar de $aes$, $q_1$ y $q_3$ son de aceptación.
    \begin{center}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0, accepting] {$q_1$};
            \node (q2) [state, below of=q0] {$q_2$};
            \node (q3) [state, below of=q1, accepting] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge [bend left] node [right] {$b$} (q2)
            (q2) edge [bend left] node [left] {$b$} (q0)
            (q2) edge [bend left] node [above] {$a$} (q3)
            (q3) edge [bend left] node [below] {$a$} (q2)
            (q1) edge [bend left] node [right] {$b$} (q3)
            (q3) edge [bend left] node [left] {$b$} (q1);
        \end{tikzpicture}
    \end{center}
    \textbf{Caso 6: }Impar de $aes$ y par de $bes$. Una cadena que debe ser aceptada es por ejemplo $abb$, luego el estado que la acepta es $q_1$, ademas note que los demás estados no son de aceptación ya que aceptan las cadenas $\lambda,b$ y $ab$ que no cumplen las condiciones.
    \begin{center}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial] {$q_0$};
            \node (q1) [state, right of=q0, accepting] {$q_1$};
            \node (q2) [state, below of=q0] {$q_2$};
            \node (q3) [state, below of=q1] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge [bend left] node [right] {$b$} (q2)
            (q2) edge [bend left] node [left] {$b$} (q0)
            (q2) edge [bend left] node [above] {$a$} (q3)
            (q3) edge [bend left] node [below] {$a$} (q2)
            (q1) edge [bend left] node [right] {$b$} (q3)
            (q3) edge [bend left] node [left] {$b$} (q1);
        \end{tikzpicture}
    \end{center}
    \textbf{Caso 7: }Par de $aes$ o Impar de $bes$.
    \begin{center}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state,  initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, below of=q0, accepting] {$q_2$};
            \node (q3) [state, below of=q1, accepting] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge [bend left] node [right] {$b$} (q2)
            (q2) edge [bend left] node [left] {$b$} (q0)
            (q2) edge [bend left] node [above] {$a$} (q3)
            (q3) edge [bend left] node [below] {$a$} (q2)
            (q1) edge [bend left] node [right] {$b$} (q3)
            (q3) edge [bend left] node [left] {$b$} (q1);
        \end{tikzpicture}
    \end{center}

Observe que por ejemplo la condición del caso $7$ es la negación de la condición del caso $6$. Ademas los estados de aceptación del caso $6$ son de no aceptación en el caso $7$ y viceversa. Esto quedaría mas que nada como una mera curiosidad sino fuera por que posteriormente se mostrara que esta es una forma de construir autómatas para lenguajes que tienen una condición negativa. Primero se construirá el autómata que acepta la condición positiva y luego para aceptar la negación se cambian los estados de aceptación a no aceptación y viceversa.
\end{itemize}


\textbf{Punto 3: }
\begin{itemize}[label={✎}]
    \item Primero debemos forzar el camino para aceptar $01$ que es la cadena mínima.
    \begin{center}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node(q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge [bend left] node [above] {$0$} (q1)
        (q1) edge [bend left] node [above] {$1$} (q2);
        \end{tikzpicture}
    \end{center}
    Ahora observe la cadena puede empezar por unos arbitrarios, estos lo generamos por medio de un bucle en el estado inicial. Luego lo mismo pasa en $q_1$ pero con ceros. Por ultimo al estar ya en el estado de aceptación note que si sale un $0$ o un $1$ la cadena dejaría de ser de aceptada y uno estaría tentado a pensar que van a un estado limbo y que el autómata quedaría de la siguiente forma:
    \begin{center}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node(q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge [bend left] node [above] {$0$} (q1)
        (q0) edge [loop above] node [above] {$1$} ()
        (q1) edge [loop above] node [above] {$0$} ()
        (q1) edge [bend left] node [above] {$1$} (q2);
        \end{tikzpicture}
    \end{center}
Pero note que las cadenas $0101$ y $101101$ son cadenas validas pero no son aceptadas por el autómata. Esto se arregla fácilmente con añadir los bucles correspondientes desde el ultimo estado.
    \begin{center}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node(q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge node [above] {$0$} (q1)
        (q0) edge [loop above] node [above] {$1$} ()
        (q1) edge [loop above] node [above] {$0$} ()
        (q2) edge [bend left] node [below] {$0$} (q1)
        (q2) edge [bend left=60] node [below] {$1$} (q0)
        (q1) edge [bend left] node [above] {$1$} (q2);
            \end{tikzpicture}
        \end{center}
        \item Primero forzamos la mínima cadena par de unos que es $11$, luego realizamos la construcción para obtener cantidad par de unos y añadimos bucles de $0$ en todos los estados ya que estos no tienen restricción alguna.
        \begin{center}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node(q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge node [above] {$1$} (q1)
        (q0) edge [loop above] node [above] {$0$} ()
        (q1) edge [loop above] node [above] {$0$} ()
        (q2) edge [bend left] node [below] {$1$} (q1)
        (q1) edge [bend left] node [above] {$1$} (q2)
        (q2) edge [loop above] node [above] {$0$} ();
            \end{tikzpicture}
        \end{center}
        \item Al igual que hacíamos con las expresiones regulares, hacemos primero que se acepten todas las cadenas de longitud $4$ que son las mínimas y posteriormente por medio de un bucle se generaran todas las demás.
        \begin{center}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node(q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1] {$q_2$};
        \node (q3) [state, right of=q2] {$q_4$};
        \node (q4) [state, right of=q3, accepting] {$q_4$};
        \path[thick]
        (q0) edge node [above] {$0,1$} (q1)
        (q1) edge node [above] {$0,1$} (q2)
        (q2) edge node [above] {$0,1$} (q3)
        (q3) edge node [above] {$0,1$} (q4)
        (q4) edge [loop above] node [above] {$0,1$} ();
            \end{tikzpicture}
        \end{center}
        \item Nuevamente forzaremos el hecho de que hayan al menos dos unos seguidos, en el primer estado agregaremos un bucle de $0$ ya que estos pueden ser arbitrarios y en el ultimo un bucle $0,1$ ya que ahi ya se cumple la condición entonces da igual que salga después
        \begin{center}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node(q0) [state, initial] {$q_0$};
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge [bend left] node [above] {$1$} (q1)
        (q0) edge [loop above] node [above] {$0$} ()
        (q1) edge [bend left] node [below] {$0$} (q0)
        (q1) edge node [above] {$1$} (q2)
        (q2) edge [loop above] node [above] {$0,1$} ();
            \end{tikzpicture}
        \end{center}
        Note que agregamos una flecha de $q_1$ a $q_0$ con etiqueta $0$ ya que esto permite aceptar cadenas como $101011001$ que sin este no serian aceptadas.

        \item Observe que debemos construir el camino forzando a que halla por lo menos un $1$ entre dos ceros (no olvide que la cadena $\lambda$ es de aceptación en este lenguaje).
        \begin{center}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
                \node (q0) [state, initial, accepting] {$q_0$};
                \node (q1) [state, right of=q0] {$q_1$};
                \node (q2) [state, right of=q1] {$q_2$};
                \node (q3) [state, right of=q2, accepting] {$q_3$};
                \path[thick]
                (q0) edge [loop above] node [above] {$1$} ()
                (q0) edge node [above] {$0$} (q1)
                (q1) edge node [above] {$1$} (q2)
                (q2) edge [loop above] node [above] {$1$} ()
                (q2) edge node [above] {$0$} (q3)
                (q3) edge [bend left] node [below] {$1$} (q0);
            \end{tikzpicture}
        \end{center}
        Note que estamos acostumbrados a que cuando hacemos la construcción de pares el bucle se hace con los que queremos forzar a ser pares, pero en este caso se vuelve al estado inicial por medio de un $1$ es debido a que la condición de que no pueden haber $2$ ceros consecutivos.
        \item Note que podemos formar los respectivos bucles por separado ya que la cadena empieza por $01$ o por $101$ y luego estas se concatenan en cualquier  orden pero siempre son esos dos bloques.
        \begin{center}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
                \node (q0) [state, initial, accepting] {$q_0$};
                \node (q1) [state, below left of=q0] {$q_1$};
                \node (q2) [state, below right of=q0] {$q_2$};
                \node (q3) [state, above of=q0] {$q_3$};
                \path[thick]
                (q0) edge [bend left] node [left] {$0$} (q3)
                (q3) edge [bend left] node [right] {$1$} (q0)
                (q0) edge node [above] {$1$} (q1)
                (q1) edge node [below] {$0$} (q2)
                (q2) edge node [above] {$1$} (q0);
            \end{tikzpicture}
        \end{center}
        \item (No se como explicarlo bien aun)
        \begin{center}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, right of=q0, accepting] {$q_1$};
            \node (q2) [state, above right of=q1] {$q_2$};
            \node (q3) [state, below right of=q1, accepting] {$q_3$};
            \node (q4) [state, below right of=q2, accepting] {$q_4$};
            \node (q5) [state, right of=q4, accepting] {$q_5$}; 
            \path [thick]
            (q0) edge node [above] {$1$} (q1)
            (q1) edge [bend left] node [above] {$0$} (q2)
            (q1) edge [bend right] node [below] {$1$} (q3)
            (q2) edge [bend left] node [above] {$1$} (q4)
            (q4) edge [bend left] node [below] {$0$} (q2)
            (q3) edge [loop below] node [below] {$1$} ()
            (q3) edge [bend right] node [below] {$0$} (q4)
            (q4) edge [bend left] node [above] {$1$} (q5)
            (q5) edge [bend left] node [below] {$0$} (q4)
            (q5) edge [loop above] node [above] {$1$} ();
            \end{tikzpicture}
        \end{center}
\end{itemize}

\textbf{Punto 4:}
\begin{itemize}[label={✎}]
    \item Basta con forzar los bucles para cada elemento y el hecho de que todas las cadenas tienen la misma secuencia de elementos, $aes$ arbitrarias luego $bes$ arbitrarias y por ultimo $ces$ arbitrarias.
    \begin{center}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0, accepting] {$q_1$};
            \node (q2) [state, right of=q1, accepting] {$q_2$};
            \path[thick]
            (q0) edge [loop above] node [above] {$a$} () 
            (q1) edge [loop above] node [above] {$b$} ()
            (q2) edge [loop above] node [above] {$c$} ()
            (q0) edge node [above] {$b$} (q1) 
            (q1) edge node [above] {$c$} (q2);
        \end{tikzpicture}
    \end{center}
    \item Haremos una construcción por dos caminos distintos a partir de las cadenas mínimas. La primera es el camino que se forma con la cadena $a$.
    \begin{center}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, above right of=q0, accepting] {$q_1$};
        \node (q2) [state, below right of=q1, accepting] {$q_2$};
        \node (q3) [state, above right of=q1, accepting] {$q_3$};
        \node (q4) [state, below right of=q3, accepting] {$q_4$};
        \path[thick]
        (q0) edge [bend left] node [above] {$a$} (q1)
        (q1) edge [bend left] node [above] {$c$} (q2)
        (q2) edge [loop below] node [below] {$c$} ()
        (q1) edge [bend left=15] node [above] {$b$} (q4)
        (q1) edge [bend left] node [above] {$a$} (q3) 
        (q3) edge [loop above] node [above] {$a$} ()
        (q3) edge [bend left] node [above] {$b$} (q4)
        (q4) edge [loop right] node [right] {$b$} ();
        \end{tikzpicture}
    \end{center}
    Esta construcción se puede ver un tanto enredada pero si nos fijamos detalladamente simplemente se están considerando tres casos, primero las cadenas de la forma $ac^*$, segundo las cadenas de la forma $ab^*$ y por ultimo las $aa^+b^*$ (note que es necesario dividir estos dos últimos caminos así debido a la definición de los AFD).
    Ahora solo nos falta construir el camino para aceptar cadenas de la forma $b^*ca^*$.
    \begin{center}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$};
        \node (q1) [state, above right of=q0, accepting] {$q_1$};
        \node (q2) [state, below right of=q1, accepting] {$q_2$};
        \node (q3) [state, above right of=q1, accepting] {$q_3$};
        \node (q4) [state, below right of=q3, accepting] {$q_4$};
        \node (q5) [state, below of=q0] {$q_5$};
        \node (q6) [state, right of=q5, accepting] {$q_6$};
        \path[thick]
        (q0) edge [bend left] node [above] {$a$} (q1)
        (q1) edge [bend left] node [above] {$c$} (q2)
        (q2) edge [loop below] node [below] {$c$} ()
        (q1) edge [bend left=15] node [above] {$b$} (q4)
        (q1) edge [bend left] node [above] {$a$} (q3) 
        (q3) edge [loop above] node [above] {$a$} ()
        (q3) edge [bend left] node [above] {$b$} (q4)
        (q4) edge [loop right] node [right] {$b$} ()
        (q0) edge node [left] {$b$} (q5)
        (q5) edge [loop below] node [below] {$b$} ()
        (q5) edge node [below] {$c$} (q6)
        (q6) edge [loop below] node [below] {$a$} ()
        (q0) edge node [above] {$c$} (q6);
        \end{tikzpicture}
    \end{center}
    Note como forzamos la cadena mínima $c$ y usamos un estado extra para generar el bucle de $bes$ ya que si no lo hacemos y colocamos ese bucle en $q_0$ alteraríamos toda la parte superior del autómata. De esta forma ya estamos considerando todas las cadenas que son dadas aceptadas en el lenguaje.
    \item Observe que las cadenas mínimas son $ba$ y $ca$ luego basta con forzarlas y notar que ademas de las $aes$ arbitrarias iniciales siempre luego de una $b$ o $c$ va una $a$ y viceversa.
    \begin{center}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
        \node (q0) [state, initial] {$q_0$}; 
        \node (q1) [state, right of=q0] {$q_1$};
        \node (q2) [state, right of=q1, accepting] {$q_2$};
        \path[thick]
        (q0) edge [loop above] node [above] {$a$} ()
        (q0) edge node [above] {$b,c$} (q1)
        (q1) edge [bend left] node [above] {$a$} (q2)
        (q2) edge [bend left] node [below] {$b,c$} (q1);
        \end{tikzpicture}
    \end{center}
\end{itemize}

\textbf{Punto 5:} Primero es bastante evidente por la definición que se nos da que la expresión regular que determina a $L$ es:
$$(aa)^*(bbb)^*=\left(a^2\right)^*\left(b^3\right)^*$$
Ahora para la construcción del AFD $M$ tal que $L(M)=L$, basta con primero realizar la construcción para obtener una cantidad par de $aes$ y posteriormente agregamos un camino para aceptar cantidad de $bes$ que sean múltiplos de $3$ (esta construcción es muy parecida a la de pares solo que en vez de concatenar bloques $bb$ estamos concatenando bloques $bbb$).
    \begin{center}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, below of=q0] {$q_2$};
            \node (q3) [state, right of=q2] {$q_3$};
            \node (q4) [state, right of=q3, accepting] {$q_4$};
            \path [thick]
            (q0) edge [bend left] node [above] {$a$} (q1)
            (q1) edge [bend left] node [below] {$a$} (q0)
            (q0) edge node [left] {$b$} (q2)
            (q2) edge node [above] {$b$} (q3)
            (q3) edge node [above] {$b$} (q4)
            (q4) edge [bend left=45] node [below] {$b$} (q2);
        \end{tikzpicture}
    \end{center}
    Uno podría pensar que para hacer que se aceptaran esos bloques de $bbb$ sobra ese estado final y se puede ahorrar haciendo que vaya una flecha de $q_3$ a $q_0$ con la etiqueta $b$, pero note que eso causaría que las cadenas de la forma $(bbb)^*(aa)^*$ fueran aceptadas lo cual no es contemplado dentro del lenguaje.
    
    $\hfill \blacklozenge$

    \section{Autómatas finitos no-deterministas (AFN)} 

  A continuación construiremos AFN los cuales no tienen las mismas restricciones que los AFD y por tanto son bastante mas sencillos de construir, eso si algo de vital importancia es que al igual que en los AFD debemos tener cuidado de no construir caminos que acepten cadenas que no son contempladas por el lenguaje.\\

  \textbf{Punto 1:}

  \begin{itemize}[label={✎}]

        \item Tenemos que asegurar que toda cadena empiece por una $a$, luego simplemente generamos los dos bucles necesarios uno para $aes$ arbitrarias y el otro para bloques $ab$.
        \begin{center}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
               \node (q0) [state, initial] {$q_0$}; 
               \node (q1) [state, right of=q0, accepting] {$q_1$};
               \node (q2) [state, right of=q1] {$q_2$};
               \path[thick]
               (q0) edge node [above] {$a$} (q1)
               (q1) edge [loop above] node [above] {$a$} ()
               (q1) edge [bend left] node [above] {$a$} (q2)
               (q2) edge [bend left] node [below] {$b$} (q1);
            \end{tikzpicture}
        \end{center}
        Observe que este es un AFN ya que hay dos flechas con etiqueta $a$ saliendo desde $q_1$.
        \item Para la construcción forzamos la cadena mínima $aa$ junto a el bucle de $aes$ inicial.
        \begin{center}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
               \node (q0) [state, initial] {$q_0$}; 
               \node (q1) [state, right of=q0] {$q_1$};
               \node (q2) [state, right of=q1, accepting] {$q_2$};
               \node (q3) [state, below of=q1] {$q_3$};
               \path[thick]
               (q0) edge node [above] {$a$} (q1)
               (q1) edge [loop above] node [above] {$a$} ()
               (q1) edge node [above] {$a$} (q2)
               (q1) edge node [left] {$b$} (q3)
               (q3) edge [loop below] node [below] {$b$} ()
               (q3) edge [bend right] node [below] {$a$} (q2);  
            \end{tikzpicture}
        \end{center}
        Note que las $bes$ intermedias las agregamos por medio de un estado extra generando un camino nuevo.
        \item Basta con construir un camino para las cadenas mínimas $a$ y $b$, luego construimos dos caminos extra para aceptar $a^*b$ y $b^*a$ respectivamente.
        \begin{center}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
               \node (q0) [state, initial] {$q_0$}; 
               \node (q1) [state, above right of=q0] {$q_1$}; 
               \node (q2) [state, below right of=q0] {$q_2$};
               \node (q3) [state, below right of=q1, accepting] {$q_3$};
               \path[thick]
               (q0) edge node [above] {$a,b$} (q3)
               (q0) edge [bend left] node [above] {$a$} (q1)
               (q1) edge [bend left] node [above] {$b$} (q3)
               (q0) edge [bend right] node [below] {$b$} (q2)
               (q2) edge [bend right] node [below] {$a$} (q3)
               (q1) edge [loop above] node [above] {$a$} ()
               (q2) edge [loop below] node [below] {$b$} ();
            \end{tikzpicture}
        \end{center}
        \item Forzaremos las $bes$ arbitrarias en el primer estado y luego generamos los caminos correspondientes para la concatenación de $ab$ y $ba$.
        \begin{center}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
               \node (q0) [state, initial, accepting] {$q_0$}; 
               \node (q1) [state, above right of=q0] {$q_1$}; 
               \node (q2) [state, below right of=q0] {$q_2$};
               \node (q3) [state, below right of=q1, accepting] {$q_3$};
               \path[thick]
               (q0) edge [loop above] node [above] {$b$} ()
               (q0) edge [bend left=15] node [above] {$a$} (q1)
               (q1) edge [bend left] node [above] {$b$} (q3)
               (q3) edge [bend left] node [below] {$a$} (q1)
               (q0) edge [bend right=15] node [below] {$b$} (q2)
               (q2) edge [bend right] node [below] {$a$} (q3)
               (q3) edge [bend right] node [above] {$b$} (q2);
            \end{tikzpicture}
        \end{center}
        \item Observe que el lenguaje es exactamente igual al anterior a excepción de que ahora las cadenas pueden terminar en un numero arbitrario de $aes$, pero como estamos construyendo un AFN basta con notar que agregando un nuevo estado que sea de aceptación con un bucle de $aes$ es suficiente.
        \begin{center}
        \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
               \node (q0) [state, initial, accepting] {$q_0$}; 
               \node (q1) [state, above right of=q0] {$q_1$}; 
               \node (q2) [state, below right of=q0] {$q_2$};
               \node (q3) [state, below right of=q1, accepting] {$q_3$};
               \node (q4) [state, right of=q3, accepting] {$q_4$};
               \path[thick]
               (q0) edge [loop above] node [above] {$b$} ()
               (q0) edge [bend left=15] node [above] {$a$} (q1)
               (q1) edge [bend left] node [above] {$b$} (q3)
               (q3) edge [bend left] node [below] {$a$} (q1)
               (q0) edge [bend right=15] node [below] {$b$} (q2)
               (q2) edge [bend right] node [below] {$a$} (q3)
               (q3) edge [bend right] node [above] {$b$} (q2)
               (q3) edge node [above] {$a$} (q4)
               (q4) edge [loop above] node [above] {$a$} ();
            \end{tikzpicture}
        \end{center}
    \end{itemize}

    \textbf{Punto 2:}  

    \begin{itemize}[label={✎}]
        \item Simplemente construimos los caminos para aceptar $01$ y $001$ por separado.
        \begin{center}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q1) [state, above right of=q0] {$q_1$};
            \node (q2) [state, below of=q0] {$q_2$};
            \node (q3) [state, right of=q2] {$q_3$};
            \path[thick]
            (q0) edge [bend left] node [above] {$0$} (q1)
            (q1) edge [bend left] node [below] {$1$} (q0)
            (q0) edge node [left] {$0$} (q2)
            (q2) edge node [below] {$0$} (q3)
            (q3) edge node [above] {$1$} (q0);
            \end{tikzpicture}
        \end{center}
        \item Nuevamente basta con construir los caminos correspondientes a $01^*0$ y $10^*$.
        \begin{center}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, below of=q0] {$q_2$};
            \path[thick]
            (q0) edge [bend left] node [above] {$0$} (q1)
            (q1) edge [bend left] node [below] {$0$} (q0)
            (q0) edge [bend right] node [left] {$1$} (q2)
            (q2) edge [bend right] node [right] {$0$} (q0)
            (q2) edge [loop below] node [below] {$0$} ()
            (q0) edge [loop above] node [above] {$1$} ()
            (q1) edge [loop above] node [above] {$1$} ();
            \end{tikzpicture}
        \end{center}
        Observe que es necesario incluir ese bucle con etiqueta $1$ para aceptar cuando solo hay unos en la expresión $10^*$ (es decir en el caso donde $1$ se concatena con $\lambda$). 
        \item Construimos los caminos de las cadenas $10^*1$ y $01$.
        \begin{center}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial] {$q_0$};
            \node (q1) [state, right of=q0] {$q_1$};
            \node (q2) [state, right of=q1, accepting] {$q_2$};
            \node (q3) [state, above of=q1] {$q_3$};
            \node (q4) [state, below of=q0] {$q_4$};
            \path[thick]
            (q0) edge node [above] {$0$} (q1)
            (q1) edge node [above] {$1$} (q2)
            (q0) edge [bend left] node [above] {$1$} (q3)
            (q3) edge [bend left] node [above] {$1$} (q2)
            (q3) edge [loop above] node [above] {$0$} ()
            (q0) edge node [left] {$1$} (q4)
            (q4) edge node [below] {$0$} (q1)
            (q4) edge [loop below] node [below] {$1$} ();
            \end{tikzpicture}
        \end{center}
        Note que usamos un estado adicional para construir el camino para aceptar $1^*01$.
    \end{itemize}

    $\hfill \blacklozenge$

    \section{Equivalencia computacional entre los AFD y los AFN}

    En la anterior sección se hizo bastante notorio como la construcción de AFN es mucho mas sencilla que la de un AFD. En esta sección se nos enseña que por medio de un proceso podemos convertir cualquier AFN en un AFD, algo que resulta extremadamente conveniente pero aveces el proceso es algo tedioso.\\ 

    \textbf{Punto 1:}\\ 
    A continuación en cada AFD que construyamos omitiremos los estados inútiles.\\

    \begin{itemize}[label={✎}]
        \item Primero realicemos la extensión de la tabla.
        \begin{center}
         \begin{tabular}{|c|c|c|}
        \hline
        $\Delta$ & $a$ & $b$\\
        \hline 
        $q_0$ & $\varnothing$ & $\{q_1,q_2\}$ \\ 
        \hline
        $q_1$ &$\{q_0\}$ &$\varnothing$ \\ 
        \hline
        $q_2$& $\{q_3\}$& $\varnothing$ \\ 
        \hline
        $q_3$&$\varnothing$&$\{q_0\}$\\ 
        \hline
        \hline  
        $\{q_1,q_2\}$&$\{q_0,q_3\}$&$\varnothing$\\ 
        \hline
        $\{q_0,q_3\}$&$\varnothing$&$\{q_0,q_1,q_2\}$\\
        \hline
        $\{q_0,q_1,q_2\}$&$\{q_0,q_3\}$&$\{q_1,q_2\}$\\ 
        \hline
        \end{tabular}   
        \end{center}
        En el AFN original teníamos que los estados de aceptación eran $q_0$ y $q_3$ luego en el AFD los estados de aceptación son todos aquellos que contengan alguno de estos dos. Luego el AFD equivalente es el siguiente:
        \begin{center}
            \begin{tikzpicture}[node distance = 2.5cm, on grid, auto]
            \node (q0) [state, initial, accepting] {$q_0$};
            \node (q1q2) [state, right of=q0] {$\{q_1,q_2\}$};
            \node (q0q3) [state, right of=q1q2, accepting] {$\{q_0,q_3\}$};
            \node (q0q1q2) [state, right of=q0q3, accepting] {$\{q_0,q_1,q_2\}$};
            \end{tikzpicture}
        \end{center}
        

    \end{itemize}
